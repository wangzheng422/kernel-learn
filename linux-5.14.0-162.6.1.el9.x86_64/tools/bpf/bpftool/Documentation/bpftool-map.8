.\" Man page generated from reStructuredText.
.
.TH BPFTOOL-MAP 8 "" "" ""
.SH NAME
bpftool-map \- tool for inspection and simple manipulation of eBPF maps
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.SH SYNOPSIS
.INDENT 0.0
.INDENT 3.5
\fBbpftool\fP [\fIOPTIONS\fP] \fBmap\fP \fICOMMAND\fP
.sp
\fIOPTIONS\fP := { { \fB\-j\fP | \fB\-\-json\fP } [{ \fB\-p\fP | \fB\-\-pretty\fP }] | { \fB\-d\fP | \fB\-\-debug\fP } |
{ \fB\-f\fP | \fB\-\-bpffs\fP } | { \fB\-n\fP | \fB\-\-nomount\fP } }
.sp
\fICOMMANDS\fP :=
{ \fBshow\fP | \fBlist\fP | \fBcreate\fP | \fBdump\fP | \fBupdate\fP | \fBlookup\fP | \fBgetnext\fP |
\fBdelete\fP | \fBpin\fP | \fBhelp\fP }
.UNINDENT
.UNINDENT
.SH MAP COMMANDS
.nf
\fBbpftool\fP \fBmap\fP { \fBshow\fP | \fBlist\fP }   [\fIMAP\fP]
\fBbpftool\fP \fBmap create\fP     \fIFILE\fP \fBtype\fP \fITYPE\fP \fBkey\fP \fIKEY_SIZE\fP \fBvalue\fP \fIVALUE_SIZE\fP 
.in +2
\fBentries\fP \fIMAX_ENTRIES\fP \fBname\fP \fINAME\fP [\fBflags\fP \fIFLAGS\fP] [\fBinner_map\fP \fIMAP\fP] 
[\fBdev\fP \fINAME\fP]
.in -2
\fBbpftool\fP \fBmap dump\fP       \fIMAP\fP
\fBbpftool\fP \fBmap update\fP     \fIMAP\fP [\fBkey\fP \fIDATA\fP] [\fBvalue\fP \fIVALUE\fP] [\fIUPDATE_FLAGS\fP]
\fBbpftool\fP \fBmap lookup\fP     \fIMAP\fP [\fBkey\fP \fIDATA\fP]
\fBbpftool\fP \fBmap getnext\fP    \fIMAP\fP [\fBkey\fP \fIDATA\fP]
\fBbpftool\fP \fBmap delete\fP     \fIMAP\fP  \fBkey\fP \fIDATA\fP
\fBbpftool\fP \fBmap pin\fP        \fIMAP\fP  \fIFILE\fP
\fBbpftool\fP \fBmap event_pipe\fP \fIMAP\fP [\fBcpu\fP \fIN\fP \fBindex\fP \fIM\fP]
\fBbpftool\fP \fBmap peek\fP       \fIMAP\fP
\fBbpftool\fP \fBmap push\fP       \fIMAP\fP \fBvalue\fP \fIVALUE\fP
\fBbpftool\fP \fBmap pop\fP        \fIMAP\fP
\fBbpftool\fP \fBmap enqueue\fP    \fIMAP\fP \fBvalue\fP \fIVALUE\fP
\fBbpftool\fP \fBmap dequeue\fP    \fIMAP\fP
\fBbpftool\fP \fBmap freeze\fP     \fIMAP\fP
\fBbpftool\fP \fBmap help\fP

\fIMAP\fP := { \fBid\fP \fIMAP_ID\fP | \fBpinned\fP \fIFILE\fP | \fBname\fP \fIMAP_NAME\fP }
\fIDATA\fP := { [\fBhex\fP] \fIBYTES\fP }
\fIPROG\fP := { \fBid\fP \fIPROG_ID\fP | \fBpinned\fP \fIFILE\fP | \fBtag\fP \fIPROG_TAG\fP | \fBname\fP \fIPROG_NAME\fP }
\fIVALUE\fP := { \fIDATA\fP | \fIMAP\fP | \fIPROG\fP }
\fIUPDATE_FLAGS\fP := { \fBany\fP | \fBexist\fP | \fBnoexist\fP }
\fITYPE\fP := { \fBhash\fP | \fBarray\fP | \fBprog_array\fP | \fBperf_event_array\fP | \fBpercpu_hash\fP
.in +2
| \fBpercpu_array\fP | \fBstack_trace\fP | \fBcgroup_array\fP | \fBlru_hash\fP
| \fBlru_percpu_hash\fP | \fBlpm_trie\fP | \fBarray_of_maps\fP | \fBhash_of_maps\fP
| \fBdevmap\fP | \fBdevmap_hash\fP | \fBsockmap\fP | \fBcpumap\fP | \fBxskmap\fP | \fBsockhash\fP
| \fBcgroup_storage\fP | \fBreuseport_sockarray\fP | \fBpercpu_cgroup_storage\fP
| \fBqueue\fP | \fBstack\fP | \fBsk_storage\fP | \fBstruct_ops\fP | \fBringbuf\fP | \fBinode_storage\fP
| \fBtask_storage\fP }
.in -2
.fi
.sp
.SH DESCRIPTION
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.TP
.B \fBbpftool map { show | list }\fP   [\fIMAP\fP]
Show information about loaded maps.  If \fIMAP\fP is specified
show information only about given maps, otherwise list all
maps currently loaded on the system.  In case of \fBname\fP,
\fIMAP\fP may match several maps which will all be shown.
.sp
Output will start with map ID followed by map type and
zero or more named attributes (depending on kernel version).
.sp
Since Linux 5.8 bpftool is able to discover information about
processes that hold open file descriptors (FDs) against BPF
maps. On such kernels bpftool will automatically emit this
information as well.
.TP
.B \fBbpftool map create\fP \fIFILE\fP \fBtype\fP \fITYPE\fP \fBkey\fP \fIKEY_SIZE\fP \fBvalue\fP \fIVALUE_SIZE\fP  \fBentries\fP \fIMAX_ENTRIES\fP \fBname\fP \fINAME\fP [\fBflags\fP \fIFLAGS\fP] [\fBinner_map\fP \fIMAP\fP] [\fBdev\fP \fINAME\fP]
Create a new map with given parameters and pin it to \fIbpffs\fP
as \fIFILE\fP\&.
.sp
\fIFLAGS\fP should be an integer which is the combination of
desired flags, e.g. 1024 for \fBBPF_F_MMAPABLE\fP (see bpf.h
UAPI header for existing flags).
.sp
To create maps of type array\-of\-maps or hash\-of\-maps, the
\fBinner_map\fP keyword must be used to pass an inner map. The
kernel needs it to collect metadata related to the inner maps
that the new map will work with.
.sp
Keyword \fBdev\fP expects a network interface name, and is used
to request hardware offload for the map.
.TP
.B \fBbpftool map dump\fP    \fIMAP\fP
Dump all entries in a given \fIMAP\fP\&.  In case of \fBname\fP,
\fIMAP\fP may match several maps which will all be dumped.
.TP
.B \fBbpftool map update\fP  \fIMAP\fP [\fBkey\fP \fIDATA\fP] [\fBvalue\fP \fIVALUE\fP] [\fIUPDATE_FLAGS\fP]
Update map entry for a given \fIKEY\fP\&.
.sp
\fIUPDATE_FLAGS\fP can be one of: \fBany\fP update existing entry
or add if doesn\(aqt exit; \fBexist\fP update only if entry already
exists; \fBnoexist\fP update only if entry doesn\(aqt exist.
.sp
If the \fBhex\fP keyword is provided in front of the bytes
sequence, the bytes are parsed as hexadecimal values, even if
no "0x" prefix is added. If the keyword is not provided, then
the bytes are parsed as decimal values, unless a "0x" prefix
(for hexadecimal) or a "0" prefix (for octal) is provided.
.TP
.B \fBbpftool map lookup\fP  \fIMAP\fP [\fBkey\fP \fIDATA\fP]
Lookup \fBkey\fP in the map.
.TP
.B \fBbpftool map getnext\fP \fIMAP\fP [\fBkey\fP \fIDATA\fP]
Get next key.  If \fIkey\fP is not specified, get first key.
.TP
.B \fBbpftool map delete\fP  \fIMAP\fP  \fBkey\fP \fIDATA\fP
Remove entry from the map.
.TP
.B \fBbpftool map pin\fP     \fIMAP\fP  \fIFILE\fP
Pin map \fIMAP\fP as \fIFILE\fP\&.
.sp
Note: \fIFILE\fP must be located in \fIbpffs\fP mount. It must not
contain a dot character (\(aq.\(aq), which is reserved for future
extensions of \fIbpffs\fP\&.
.TP
.B \fBbpftool\fP \fBmap event_pipe\fP \fIMAP\fP [\fBcpu\fP \fIN\fP \fBindex\fP \fIM\fP]
Read events from a \fBBPF_MAP_TYPE_PERF_EVENT_ARRAY\fP map.
.sp
Install perf rings into a perf event array map and dump
output of any \fBbpf_perf_event_output\fP() call in the kernel.
By default read the number of CPUs on the system and
install perf ring for each CPU in the corresponding index
in the array.
.sp
If \fBcpu\fP and \fBindex\fP are specified, install perf ring
for given \fBcpu\fP at \fBindex\fP in the array (single ring).
.sp
Note that installing a perf ring into an array will silently
replace any existing ring.  Any other application will stop
receiving events if it installed its rings earlier.
.TP
.B \fBbpftool map peek\fP  \fIMAP\fP
Peek next value in the queue or stack.
.TP
.B \fBbpftool map push\fP  \fIMAP\fP \fBvalue\fP \fIVALUE\fP
Push \fIVALUE\fP onto the stack.
.TP
.B \fBbpftool map pop\fP  \fIMAP\fP
Pop and print value from the stack.
.TP
.B \fBbpftool map enqueue\fP  \fIMAP\fP \fBvalue\fP \fIVALUE\fP
Enqueue \fIVALUE\fP into the queue.
.TP
.B \fBbpftool map dequeue\fP  \fIMAP\fP
Dequeue and print value from the queue.
.TP
.B \fBbpftool map freeze\fP  \fIMAP\fP
Freeze the map as read\-only from user space. Entries from a
frozen map can not longer be updated or deleted with the
\fBbpf\fP() system call. This operation is not reversible,
and the map remains immutable from user space until its
destruction. However, read and write permissions for BPF
programs to the map remain unchanged.
.TP
.B \fBbpftool map help\fP
Print short help message.
.UNINDENT
.UNINDENT
.UNINDENT
.SH OPTIONS
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.TP
.B \-h\fP,\fB  \-\-help
Print short help message (similar to \fBbpftool help\fP).
.TP
.B \-V\fP,\fB  \-\-version
Print version number (similar to \fBbpftool version\fP), and optional
features that were included when bpftool was compiled. Optional
features include linking against libbfd to provide the disassembler
for JIT\-ted programs (\fBbpftool prog dump jited\fP) and usage of BPF
skeletons (some features like \fBbpftool prog profile\fP or showing
pids associated to BPF objects may rely on it).
.TP
.B \-j\fP,\fB  \-\-json
Generate JSON output. For commands that cannot produce JSON, this
option has no effect.
.TP
.B \-p\fP,\fB  \-\-pretty
Generate human\-readable JSON output. Implies \fB\-j\fP\&.
.TP
.B \-d\fP,\fB  \-\-debug
Print all logs available, even debug\-level information. This includes
logs from libbpf as well as from the verifier, when attempting to
load programs.
.TP
.B \-l\fP,\fB  \-\-legacy
Use legacy libbpf mode which has more relaxed BPF program
requirements. By default, bpftool has more strict requirements
about section names, changes pinning logic and doesn\(aqt support
some of the older non\-BTF map declarations.
.sp
See \fI\%https://github.com/libbpf/libbpf/wiki/Libbpf:\-the\-road\-to\-v1.0\fP
for details.
.TP
.B \-f\fP,\fB  \-\-bpffs
Show file names of pinned maps.
.TP
.B \-n\fP,\fB  \-\-nomount
Do not automatically attempt to mount any virtual file system
(such as tracefs or BPF virtual file system) when necessary.
.UNINDENT
.UNINDENT
.UNINDENT
.SH EXAMPLES
.sp
\fB# bpftool map show\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
10: hash  name some_map  flags 0x0
      key 4B  value 8B  max_entries 2048  memlock 167936B
      pids systemd(1)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The following three commands are equivalent:
.nf

\fB# bpftool map update id 10 key hex   20   c4   b7   00 value hex   0f   ff   ff   ab   01   02   03   4c\fP
\fB# bpftool map update id 10 key     0x20 0xc4 0xb7 0x00 value     0x0f 0xff 0xff 0xab 0x01 0x02 0x03 0x4c\fP
\fB# bpftool map update id 10 key       32  196  183    0 value       15  255  255  171    1    2    3   76\fP
.fi
.sp
.sp
\fB# bpftool map lookup id 10 key 0 1 2 3\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
key: 00 01 02 03 value: 00 01 02 03 04 05 06 07
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB# bpftool map dump id 10\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
key: 00 01 02 03  value: 00 01 02 03 04 05 06 07
key: 0d 00 07 00  value: 02 00 00 00 01 02 03 04
Found 2 elements
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB# bpftool map getnext id 10 key 0 1 2 3\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
key:
00 01 02 03
next key:
0d 00 07 00
.ft P
.fi
.UNINDENT
.UNINDENT
.nf

\fB# mount \-t bpf none /sys/fs/bpf/\fP
\fB# bpftool map pin id 10 /sys/fs/bpf/map\fP
\fB# bpftool map del pinned /sys/fs/bpf/map key 13 00 07 00\fP
.fi
.sp
.sp
Note that map update can also be used in order to change the program references
hold by a program array map. This can be used, for example, to change the
programs used for tail\-call jumps at runtime, without having to reload the
entry\-point program. Below is an example for this use case: we load a program
defining a prog array map, and with a main function that contains a tail call
to other programs that can be used either to "process" packets or to "debug"
processing. Note that the prog array map MUST be pinned into the BPF virtual
file system for the map update to work successfully, as kernel flushes prog
array maps when they have no more references from user space (and the update
would be lost as soon as bpftool exits).
.nf

\fB# bpftool prog loadall tail_calls.o /sys/fs/bpf/foo type xdp\fP
\fB# bpftool prog \-\-bpffs\fP
.fi
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
545: xdp  name main_func  tag 674b4b5597193dc3  gpl
        loaded_at 2018\-12\-12T15:02:58+0000  uid 0
        xlated 240B  jited 257B  memlock 4096B  map_ids 294
        pinned /sys/fs/bpf/foo/xdp
546: xdp  name bpf_func_process  tag e369a529024751fc  gpl
        loaded_at 2018\-12\-12T15:02:58+0000  uid 0
        xlated 200B  jited 164B  memlock 4096B
        pinned /sys/fs/bpf/foo/process
547: xdp  name bpf_func_debug  tag 0b597868bc7f0976  gpl
        loaded_at 2018\-12\-12T15:02:58+0000  uid 0
        xlated 200B  jited 164B  memlock 4096B
        pinned /sys/fs/bpf/foo/debug
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB# bpftool map\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
294: prog_array  name jmp_table  flags 0x0
        key 4B  value 4B  max_entries 1  memlock 4096B
        owner_prog_type xdp  owner jited
.ft P
.fi
.UNINDENT
.UNINDENT
.nf

\fB# bpftool map pin id 294 /sys/fs/bpf/bar\fP
\fB# bpftool map dump pinned /sys/fs/bpf/bar\fP
.fi
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Found 0 elements
.ft P
.fi
.UNINDENT
.UNINDENT
.nf

\fB# bpftool map update pinned /sys/fs/bpf/bar key 0 0 0 0 value pinned /sys/fs/bpf/foo/debug\fP
\fB# bpftool map dump pinned /sys/fs/bpf/bar\fP
.fi
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
key: 00 00 00 00  value: 22 02 00 00
Found 1 element
.ft P
.fi
.UNINDENT
.UNINDENT
.SH SEE ALSO
.INDENT 0.0
.INDENT 3.5
\fBbpf\fP(2),
\fBbpf\-helpers\fP(7),
\fBbpftool\fP(8),
\fBbpftool\-btf\fP(8),
\fBbpftool\-cgroup\fP(8),
\fBbpftool\-feature\fP(8),
\fBbpftool\-gen\fP(8),
\fBbpftool\-iter\fP(8),
\fBbpftool\-link\fP(8),
\fBbpftool\-net\fP(8),
\fBbpftool\-perf\fP(8),
\fBbpftool\-prog\fP(8),
\fBbpftool\-struct_ops\fP(8)
.UNINDENT
.UNINDENT
.\" Generated by docutils manpage writer.
.
