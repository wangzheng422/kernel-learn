<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<?asciidoc-toc?>
<?asciidoc-numbered?>
<refentry>
<refentryinfo><date></date></refentryinfo>
<refmeta>
<refentrytitle>perf-intel-pt</refentrytitle>
<manvolnum>1</manvolnum>
<refmiscinfo class="source">perf</refmiscinfo>
<refmiscinfo class="version"></refmiscinfo>
<refmiscinfo class="manual">perf Manual</refmiscinfo>
</refmeta>
<refnamediv>
  <refname>perf-intel-pt</refname>
  <refpurpose>Support for Intel Processor Trace within perf tools</refpurpose>
</refnamediv>
<refsynopsisdiv id="_synopsis">
<blockquote>
<literallayout><emphasis>perf record</emphasis> -e intel_pt//</literallayout>
</blockquote>
</refsynopsisdiv>
<refsect1 id="_description">
<title>DESCRIPTION</title>
<simpara>Intel Processor Trace (Intel PT) is an extension of Intel Architecture that
collects information about software execution such as control flow, execution
modes and timings and formats it into highly compressed binary packets.
Technical details are documented in the Intel 64 and IA-32 Architectures
Software Developer Manuals, Chapter 36 Intel Processor Trace.</simpara>
<simpara>Intel PT is first supported in Intel Core M and 5th generation Intel Core
processors that are based on the Intel micro-architecture code name Broadwell.</simpara>
<simpara>Trace data is collected by <emphasis>perf record</emphasis> and stored within the perf.data file.
See below for options to <emphasis>perf record</emphasis>.</simpara>
<simpara>Trace data must be <emphasis>decoded</emphasis> which involves walking the object code and matching
the trace data packets. For example a TNT packet only tells whether a
conditional branch was taken or not taken, so to make use of that packet the
decoder must know precisely which instruction was being executed.</simpara>
<simpara>Decoding is done on-the-fly.  The decoder outputs samples in the same format as
samples output by perf hardware events, for example as though the "instructions"
or "branches" events had been recorded.  Presently 3 tools support this:
<emphasis>perf script</emphasis>, <emphasis>perf report</emphasis> and <emphasis>perf inject</emphasis>.  See below for more information
on using those tools.</simpara>
<simpara>The main distinguishing feature of Intel PT is that the decoder can determine
the exact flow of software execution.  Intel PT can be used to understand why
and how did software get to a certain point, or behave a certain way.  The
software does not have to be recompiled, so Intel PT works with debug or release
builds, however the executed images are needed - which makes use in JIT-compiled
environments, or with self-modified code, a challenge.  Also symbols need to be
provided to make sense of addresses.</simpara>
<simpara>A limitation of Intel PT is that it produces huge amounts of trace data
(hundreds of megabytes per second per core) which takes a long time to decode,
for example two or three orders of magnitude longer than it took to collect.
Another limitation is the performance impact of tracing, something that will
vary depending on the use-case and architecture.</simpara>
</refsect1>
<refsect1 id="_quickstart">
<title>Quickstart</title>
<simpara>It is important to start small.  That is because it is easy to capture vastly
more data than can possibly be processed.</simpara>
<simpara>The simplest thing to do with Intel PT is userspace profiling of small programs.
Data is captured with <emphasis>perf record</emphasis> e.g. to trace <emphasis>ls</emphasis> userspace-only:</simpara>
<literallayout class="monospaced">perf record -e intel_pt//u ls</literallayout>
<simpara>And profiled with <emphasis>perf report</emphasis> e.g.</simpara>
<literallayout class="monospaced">perf report</literallayout>
<simpara>To also trace kernel space presents a problem, namely kernel self-modifying
code.  A fairly good kernel image is available in /proc/kcore but to get an
accurate image a copy of /proc/kcore needs to be made under the same conditions
as the data capture. <emphasis>perf record</emphasis> can make a copy of /proc/kcore if the option
--kcore is used, but access to /proc/kcore is restricted e.g.</simpara>
<literallayout class="monospaced">sudo perf record -o pt_ls --kcore -e intel_pt// -- ls</literallayout>
<simpara>which will create a directory named <emphasis>pt_ls</emphasis> and put the perf.data file (named
simply <emphasis>data</emphasis>) and copies of /proc/kcore, /proc/kallsyms and /proc/modules into
it.  The other tools understand the directory format, so to use <emphasis>perf report</emphasis>
becomes:</simpara>
<literallayout class="monospaced">sudo perf report -i pt_ls</literallayout>
<simpara>Because samples are synthesized after-the-fact, the sampling period can be
selected for reporting. e.g. sample every microsecond</simpara>
<literallayout class="monospaced">sudo perf report pt_ls --itrace=i1usge</literallayout>
<simpara>See the sections below for more information about the --itrace option.</simpara>
<simpara>Beware the smaller the period, the more samples that are produced, and the
longer it takes to process them.</simpara>
<simpara>Also note that the coarseness of Intel PT timing information will start to
distort the statistical value of the sampling as the sampling period becomes
smaller.</simpara>
<simpara>To represent software control flow, "branches" samples are produced.  By default
a branch sample is synthesized for every single branch.  To get an idea what
data is available you can use the <emphasis>perf script</emphasis> tool with all itrace sampling
options, which will list all the samples.</simpara>
<literallayout class="monospaced">perf record -e intel_pt//u ls
perf script --itrace=ibxwpe</literallayout>
<simpara>An interesting field that is not printed by default is <emphasis>flags</emphasis> which can be
displayed as follows:</simpara>
<literallayout class="monospaced">perf script --itrace=ibxwpe -F+flags</literallayout>
<simpara>The flags are "bcrosyiABExgh" which stand for branch, call, return, conditional,
system, asynchronous, interrupt, transaction abort, trace begin, trace end,
in transaction, VM-entry, and VM-exit respectively.</simpara>
<simpara>perf script also supports higher level ways to dump instruction traces:</simpara>
<literallayout class="monospaced">perf script --insn-trace --xed</literallayout>
<simpara>Dump all instructions. This requires installing the xed tool (see XED below)
Dumping all instructions in a long trace can be fairly slow. It is usually better
to start with higher level decoding, like</simpara>
<literallayout class="monospaced">perf script --call-trace</literallayout>
<simpara>or</simpara>
<literallayout class="monospaced">perf script --call-ret-trace</literallayout>
<simpara>and then select a time range of interest. The time range can then be examined
in detail with</simpara>
<literallayout class="monospaced">perf script --time starttime,stoptime --insn-trace --xed</literallayout>
<simpara>While examining the trace it&#8217;s also useful to filter on specific CPUs using
the -C option</simpara>
<literallayout class="monospaced">perf script --time starttime,stoptime --insn-trace --xed -C 1</literallayout>
<simpara>Dump all instructions in time range on CPU 1.</simpara>
<simpara>Another interesting field that is not printed by default is <emphasis>ipc</emphasis> which can be
displayed as follows:</simpara>
<literallayout class="monospaced">perf script --itrace=be -F+ipc</literallayout>
<simpara>There are two ways that instructions-per-cycle (IPC) can be calculated depending
on the recording.</simpara>
<simpara>If the <emphasis>cyc</emphasis> config term (see config terms section below) was used, then IPC is
calculated using the cycle count from CYC packets, otherwise MTC packets are
used - refer to the <emphasis>mtc</emphasis> config term.  When MTC is used, however, the values
are less accurate because the timing is less accurate.</simpara>
<simpara>Because Intel PT does not update the cycle count on every branch or instruction,
the values will often be zero.  When there are values, they will be the number
of instructions and number of cycles since the last update, and thus represent
the average IPC since the last IPC for that event type.  Note IPC for "branches"
events is calculated separately from IPC for "instructions" events.</simpara>
<simpara>Even with the <emphasis>cyc</emphasis> config term, it is possible to produce IPC information for
every change of timestamp, but at the expense of accuracy.  That is selected by
specifying the itrace <emphasis>A</emphasis> option.  Due to the granularity of timestamps, the
actual number of cycles increases even though the cycles reported does not.
The number of instructions is known, but if IPC is reported, cycles can be too
low and so IPC is too high.  Note that inaccuracy decreases as the period of
sampling increases i.e. if the number of cycles is too low by a small amount,
that becomes less significant if the number of cycles is large.  It may also be
useful to use the <emphasis>A</emphasis> option in conjunction with dlfilter-show-cycles.so to
provide higher granularity cycle information.</simpara>
<simpara>Also note that the IPC instruction count may or may not include the current
instruction.  If the cycle count is associated with an asynchronous branch
(e.g. page fault or interrupt), then the instruction count does not include the
current instruction, otherwise it does.  That is consistent with whether or not
that instruction has retired when the cycle count is updated.</simpara>
<simpara>Another note, in the case of "branches" events, non-taken branches are not
presently sampled, so IPC values for them do not appear e.g. a CYC packet with a
TNT packet that starts with a non-taken branch.  To see every possible IPC
value, "instructions" events can be used e.g. --itrace=i0ns</simpara>
<simpara>While it is possible to create scripts to analyze the data, an alternative
approach is available to export the data to a sqlite or postgresql database.
Refer to script export-to-sqlite.py or export-to-postgresql.py for more details,
and to script exported-sql-viewer.py for an example of using the database.</simpara>
<simpara>There is also script intel-pt-events.py which provides an example of how to
unpack the raw data for power events and PTWRITE. The script also displays
branches, and supports 2 additional modes selected by option:</simpara>
<literallayout class="monospaced">--insn-trace - instruction trace
--src-trace - source trace</literallayout>
<simpara>As mentioned above, it is easy to capture too much data.  One way to limit the
data captured is to use <emphasis>snapshot</emphasis> mode which is explained further below.
Refer to <emphasis>new snapshot option</emphasis> and <emphasis>Intel PT modes of operation</emphasis> further below.</simpara>
<simpara>Another problem that will be experienced is decoder errors.  They can be caused
by inability to access the executed image, self-modified or JIT-ed code, or the
inability to match side-band information (such as context switches and mmaps)
which results in the decoder not knowing what code was executed.</simpara>
<simpara>There is also the problem of perf not being able to copy the data fast enough,
resulting in data lost because the buffer was full.  See <emphasis>Buffer handling</emphasis> below
for more details.</simpara>
</refsect1>
<refsect1 id="_perf_record">
<title>perf record</title>
<refsect2 id="_new_event">
<title>new event</title>
<simpara>The Intel PT kernel driver creates a new PMU for Intel PT.  PMU events are
selected by providing the PMU name followed by the "config" separated by slashes.
An enhancement has been made to allow default "config" e.g. the option</simpara>
<literallayout class="monospaced">-e intel_pt//</literallayout>
<simpara>will use a default config value.  Currently that is the same as</simpara>
<literallayout class="monospaced">-e intel_pt/tsc,noretcomp=0/</literallayout>
<simpara>which is the same as</simpara>
<literallayout class="monospaced">-e intel_pt/tsc=1,noretcomp=0/</literallayout>
<simpara>Note there are now new config terms - see section <emphasis>config terms</emphasis> further below.</simpara>
<simpara>The config terms are listed in /sys/devices/intel_pt/format.  They are bit
fields within the config member of the struct perf_event_attr which is
passed to the kernel by the perf_event_open system call.  They correspond to bit
fields in the IA32_RTIT_CTL MSR.  Here is a list of them and their definitions:</simpara>
<literallayout class="monospaced">$ grep -H . /sys/bus/event_source/devices/intel_pt/format/*
/sys/bus/event_source/devices/intel_pt/format/cyc:config:1
/sys/bus/event_source/devices/intel_pt/format/cyc_thresh:config:19-22
/sys/bus/event_source/devices/intel_pt/format/mtc:config:9
/sys/bus/event_source/devices/intel_pt/format/mtc_period:config:14-17
/sys/bus/event_source/devices/intel_pt/format/noretcomp:config:11
/sys/bus/event_source/devices/intel_pt/format/psb_period:config:24-27
/sys/bus/event_source/devices/intel_pt/format/tsc:config:10</literallayout>
<simpara>Note that the default config must be overridden for each term i.e.</simpara>
<literallayout class="monospaced">-e intel_pt/noretcomp=0/</literallayout>
<simpara>is the same as:</simpara>
<literallayout class="monospaced">-e intel_pt/tsc=1,noretcomp=0/</literallayout>
<simpara>So, to disable TSC packets use:</simpara>
<literallayout class="monospaced">-e intel_pt/tsc=0/</literallayout>
<simpara>It is also possible to specify the config value explicitly:</simpara>
<literallayout class="monospaced">-e intel_pt/config=0x400/</literallayout>
<simpara>Note that, as with all events, the event is suffixed with event modifiers:</simpara>
<literallayout class="monospaced">u       userspace
k       kernel
h       hypervisor
G       guest
H       host
p       precise ip</literallayout>
<simpara><emphasis>h</emphasis>, <emphasis>G</emphasis> and <emphasis>H</emphasis> are for virtualization which is not supported by Intel PT.
<emphasis>p</emphasis> is also not relevant to Intel PT.  So only options <emphasis>u</emphasis> and <emphasis>k</emphasis> are
meaningful for Intel PT.</simpara>
<simpara>perf_event_attr is displayed if the -vv option is used e.g.</simpara>
<literallayout class="monospaced">------------------------------------------------------------
perf_event_attr:
type                             6
size                             112
config                           0x400
{ sample_period, sample_freq }   1
sample_type                      IP|TID|TIME|CPU|IDENTIFIER
read_format                      ID
disabled                         1
inherit                          1
exclude_kernel                   1
exclude_hv                       1
enable_on_exec                   1
sample_id_all                    1
------------------------------------------------------------
sys_perf_event_open: pid 31104  cpu 0  group_fd -1  flags 0x8
sys_perf_event_open: pid 31104  cpu 1  group_fd -1  flags 0x8
sys_perf_event_open: pid 31104  cpu 2  group_fd -1  flags 0x8
sys_perf_event_open: pid 31104  cpu 3  group_fd -1  flags 0x8
------------------------------------------------------------</literallayout>
</refsect2>
<refsect2 id="_config_terms">
<title>config terms</title>
<simpara>The June 2015 version of Intel 64 and IA-32 Architectures Software Developer
Manuals, Chapter 36 Intel Processor Trace, defined new Intel PT features.
Some of the features are reflect in new config terms.  All the config terms are
described below.</simpara>
<simpara>tsc             Always supported.  Produces TSC timestamp packets to provide
                timing information.  In some cases it is possible to decode
                without timing information, for example a per-thread context
                that does not overlap executable memory maps.</simpara>
<literallayout class="monospaced">The default config selects tsc (i.e. tsc=1).</literallayout>
<simpara>noretcomp       Always supported.  Disables "return compression" so a TIP packet
                is produced when a function returns.  Causes more packets to be
                produced but might make decoding more reliable.</simpara>
<literallayout class="monospaced">The default config does not select noretcomp (i.e. noretcomp=0).</literallayout>
<simpara>psb_period      Allows the frequency of PSB packets to be specified.</simpara>
<literallayout class="monospaced">The PSB packet is a synchronization packet that provides a
starting point for decoding or recovery from errors.</literallayout>
<literallayout class="monospaced">Support for psb_period is indicated by:</literallayout>
<literallayout class="monospaced">/sys/bus/event_source/devices/intel_pt/caps/psb_cyc</literallayout>
<literallayout class="monospaced">which contains "1" if the feature is supported and "0"
otherwise.</literallayout>
<literallayout class="monospaced">Valid values are given by:</literallayout>
<literallayout class="monospaced">/sys/bus/event_source/devices/intel_pt/caps/psb_periods</literallayout>
<literallayout class="monospaced">which contains a hexadecimal value, the bits of which represent
valid values e.g. bit 2 set means value 2 is valid.</literallayout>
<literallayout class="monospaced">The psb_period value is converted to the approximate number of
trace bytes between PSB packets as:</literallayout>
<literallayout class="monospaced">2 ^ (value + 11)</literallayout>
<literallayout class="monospaced">e.g. value 3 means 16KiB bytes between PSBs</literallayout>
<literallayout class="monospaced">If an invalid value is entered, the error message
will give a list of valid values e.g.</literallayout>
<literallayout class="monospaced">$ perf record -e intel_pt/psb_period=15/u uname
Invalid psb_period for intel_pt. Valid values are: 0-5</literallayout>
<literallayout class="monospaced">If MTC packets are selected, the default config selects a value
of 3 (i.e. psb_period=3) or the nearest lower value that is
supported (0 is always supported).  Otherwise the default is 0.</literallayout>
<literallayout class="monospaced">If decoding is expected to be reliable and the buffer is large
then a large PSB period can be used.</literallayout>
<literallayout class="monospaced">Because a TSC packet is produced with PSB, the PSB period can
also affect the granularity to timing information in the absence
of MTC or CYC.</literallayout>
<simpara>mtc             Produces MTC timing packets.</simpara>
<literallayout class="monospaced">MTC packets provide finer grain timestamp information than TSC
packets.  MTC packets record time using the hardware crystal
clock (CTC) which is related to TSC packets using a TMA packet.</literallayout>
<literallayout class="monospaced">Support for this feature is indicated by:</literallayout>
<literallayout class="monospaced">/sys/bus/event_source/devices/intel_pt/caps/mtc</literallayout>
<literallayout class="monospaced">which contains "1" if the feature is supported and
"0" otherwise.</literallayout>
<literallayout class="monospaced">The frequency of MTC packets can also be specified - see
mtc_period below.</literallayout>
<simpara>mtc_period      Specifies how frequently MTC packets are produced - see mtc
                above for how to determine if MTC packets are supported.</simpara>
<literallayout class="monospaced">Valid values are given by:</literallayout>
<literallayout class="monospaced">/sys/bus/event_source/devices/intel_pt/caps/mtc_periods</literallayout>
<literallayout class="monospaced">which contains a hexadecimal value, the bits of which represent
valid values e.g. bit 2 set means value 2 is valid.</literallayout>
<literallayout class="monospaced">The mtc_period value is converted to the MTC frequency as:</literallayout>
<literallayout class="monospaced">CTC-frequency / (2 ^ value)</literallayout>
<literallayout class="monospaced">e.g. value 3 means one eighth of CTC-frequency</literallayout>
<literallayout class="monospaced">Where CTC is the hardware crystal clock, the frequency of which
can be related to TSC via values provided in cpuid leaf 0x15.</literallayout>
<literallayout class="monospaced">If an invalid value is entered, the error message
will give a list of valid values e.g.</literallayout>
<literallayout class="monospaced">$ perf record -e intel_pt/mtc_period=15/u uname
Invalid mtc_period for intel_pt. Valid values are: 0,3,6,9</literallayout>
<literallayout class="monospaced">The default value is 3 or the nearest lower value
that is supported (0 is always supported).</literallayout>
<simpara>cyc             Produces CYC timing packets.</simpara>
<literallayout class="monospaced">CYC packets provide even finer grain timestamp information than
MTC and TSC packets.  A CYC packet contains the number of CPU
cycles since the last CYC packet. Unlike MTC and TSC packets,
CYC packets are only sent when another packet is also sent.</literallayout>
<literallayout class="monospaced">Support for this feature is indicated by:</literallayout>
<literallayout class="monospaced">/sys/bus/event_source/devices/intel_pt/caps/psb_cyc</literallayout>
<literallayout class="monospaced">which contains "1" if the feature is supported and
"0" otherwise.</literallayout>
<literallayout class="monospaced">The number of CYC packets produced can be reduced by specifying
a threshold - see cyc_thresh below.</literallayout>
<simpara>cyc_thresh      Specifies how frequently CYC packets are produced - see cyc
                above for how to determine if CYC packets are supported.</simpara>
<literallayout class="monospaced">Valid cyc_thresh values are given by:</literallayout>
<literallayout class="monospaced">/sys/bus/event_source/devices/intel_pt/caps/cycle_thresholds</literallayout>
<literallayout class="monospaced">which contains a hexadecimal value, the bits of which represent
valid values e.g. bit 2 set means value 2 is valid.</literallayout>
<literallayout class="monospaced">The cyc_thresh value represents the minimum number of CPU cycles
that must have passed before a CYC packet can be sent.  The
number of CPU cycles is:</literallayout>
<literallayout class="monospaced">2 ^ (value - 1)</literallayout>
<literallayout class="monospaced">e.g. value 4 means 8 CPU cycles must pass before a CYC packet
can be sent.  Note a CYC packet is still only sent when another
packet is sent, not at, e.g. every 8 CPU cycles.</literallayout>
<literallayout class="monospaced">If an invalid value is entered, the error message
will give a list of valid values e.g.</literallayout>
<literallayout class="monospaced">$ perf record -e intel_pt/cyc,cyc_thresh=15/u uname
Invalid cyc_thresh for intel_pt. Valid values are: 0-12</literallayout>
<literallayout class="monospaced">CYC packets are not requested by default.</literallayout>
<simpara>pt              Specifies pass-through which enables the <emphasis>branch</emphasis> config term.</simpara>
<literallayout class="monospaced">The default config selects 'pt' if it is available, so a user will
never need to specify this term.</literallayout>
<simpara>branch          Enable branch tracing.  Branch tracing is enabled by default so to
                disable branch tracing use <emphasis>branch=0</emphasis>.</simpara>
<literallayout class="monospaced">The default config selects 'branch' if it is available.</literallayout>
<simpara>ptw             Enable PTWRITE packets which are produced when a ptwrite instruction
                is executed.</simpara>
<literallayout class="monospaced">Support for this feature is indicated by:</literallayout>
<literallayout class="monospaced">/sys/bus/event_source/devices/intel_pt/caps/ptwrite</literallayout>
<literallayout class="monospaced">which contains "1" if the feature is supported and
"0" otherwise.</literallayout>
<simpara>fup_on_ptw      Enable a FUP packet to follow the PTWRITE packet.  The FUP packet
                provides the address of the ptwrite instruction.  In the absence of
                fup_on_ptw, the decoder will use the address of the previous branch
                if branch tracing is enabled, otherwise the address will be zero.
                Note that fup_on_ptw will work even when branch tracing is disabled.</simpara>
<simpara>pwr_evt         Enable power events.  The power events provide information about
                changes to the CPU C-state.</simpara>
<literallayout class="monospaced">Support for this feature is indicated by:</literallayout>
<literallayout class="monospaced">/sys/bus/event_source/devices/intel_pt/caps/power_event_trace</literallayout>
<literallayout class="monospaced">which contains "1" if the feature is supported and
"0" otherwise.</literallayout>
</refsect2>
<refsect2 id="_aux_area_sampling_option">
<title>AUX area sampling option</title>
<simpara>To select Intel PT "sampling" the AUX area sampling option can be used:</simpara>
<literallayout class="monospaced">--aux-sample</literallayout>
<simpara>Optionally it can be followed by the sample size in bytes e.g.</simpara>
<literallayout class="monospaced">--aux-sample=8192</literallayout>
<simpara>In addition, the Intel PT event to sample must be defined e.g.</simpara>
<literallayout class="monospaced">-e intel_pt//u</literallayout>
<simpara>Samples on other events will be created containing Intel PT data e.g. the
following will create Intel PT samples on the branch-misses event, note the
events must be grouped using {}:</simpara>
<literallayout class="monospaced">perf record --aux-sample -e '{intel_pt//u,branch-misses:u}'</literallayout>
<simpara>An alternative to <emphasis>--aux-sample</emphasis> is to add the config term <emphasis>aux-sample-size</emphasis> to
events.  In this case, the grouping is implied e.g.</simpara>
<literallayout class="monospaced">perf record -e intel_pt//u -e branch-misses/aux-sample-size=8192/u</literallayout>
<simpara>is the same as:</simpara>
<literallayout class="monospaced">perf record -e '{intel_pt//u,branch-misses/aux-sample-size=8192/u}'</literallayout>
<simpara>but allows for also using an address filter e.g.:</simpara>
<literallayout class="monospaced">perf record -e intel_pt//u --filter 'filter * @/bin/ls' -e branch-misses/aux-sample-size=8192/u -- ls</literallayout>
<simpara>It is important to select a sample size that is big enough to contain at least
one PSB packet.  If not a warning will be displayed:</simpara>
<literallayout class="monospaced">Intel PT sample size (%zu) may be too small for PSB period (%zu)</literallayout>
<simpara>The calculation used for that is: if sample_size &#8656; psb_period + 256 display the
warning.  When sampling is used, psb_period defaults to 0 (2KiB).</simpara>
<simpara>The default sample size is 4KiB.</simpara>
<simpara>The sample size is passed in aux_sample_size in struct perf_event_attr.  The
sample size is limited by the maximum event size which is 64KiB.  It is
difficult to know how big the event might be without the trace sample attached,
but the tool validates that the sample size is not greater than 60KiB.</simpara>
</refsect2>
<refsect2 id="_new_snapshot_option">
<title>new snapshot option</title>
<simpara>The difference between full trace and snapshot from the kernel&#8217;s perspective is
that in full trace we don&#8217;t overwrite trace data that the user hasn&#8217;t collected
yet (and indicated that by advancing aux_tail), whereas in snapshot mode we let
the trace run and overwrite older data in the buffer so that whenever something
interesting happens, we can stop it and grab a snapshot of what was going on
around that interesting moment.</simpara>
<simpara>To select snapshot mode a new option has been added:</simpara>
<literallayout class="monospaced">-S</literallayout>
<simpara>Optionally it can be followed by the snapshot size e.g.</simpara>
<literallayout class="monospaced">-S0x100000</literallayout>
<simpara>The default snapshot size is the auxtrace mmap size.  If neither auxtrace mmap size
nor snapshot size is specified, then the default is 4MiB for privileged users
(or if /proc/sys/kernel/perf_event_paranoid &lt; 0), 128KiB for unprivileged users.
If an unprivileged user does not specify mmap pages, the mmap pages will be
reduced as described in the <emphasis>new auxtrace mmap size option</emphasis> section below.</simpara>
<simpara>The snapshot size is displayed if the option -vv is used e.g.</simpara>
<literallayout class="monospaced">Intel PT snapshot size: %zu</literallayout>
</refsect2>
<refsect2 id="_new_auxtrace_mmap_size_option">
<title>new auxtrace mmap size option</title>
<simpara>Intel PT buffer size is specified by an addition to the -m option e.g.</simpara>
<literallayout class="monospaced">-m,16</literallayout>
<simpara>selects a buffer size of 16 pages i.e. 64KiB.</simpara>
<simpara>Note that the existing functionality of -m is unchanged.  The auxtrace mmap size
is specified by the optional addition of a comma and the value.</simpara>
<simpara>The default auxtrace mmap size for Intel PT is 4MiB/page_size for privileged users
(or if /proc/sys/kernel/perf_event_paranoid &lt; 0), 128KiB for unprivileged users.
If an unprivileged user does not specify mmap pages, the mmap pages will be
reduced from the default 512KiB/page_size to 256KiB/page_size, otherwise the
user is likely to get an error as they exceed their mlock limit (Max locked
memory as shown in /proc/self/limits).  Note that perf does not count the first
512KiB (actually /proc/sys/kernel/perf_event_mlock_kb minus 1 page) per cpu
against the mlock limit so an unprivileged user is allowed 512KiB per cpu plus
their mlock limit (which defaults to 64KiB but is not multiplied by the number
of cpus).</simpara>
<simpara>In full-trace mode, powers of two are allowed for buffer size, with a minimum
size of 2 pages.  In snapshot mode or sampling mode, it is the same but the
minimum size is 1 page.</simpara>
<simpara>The mmap size and auxtrace mmap size are displayed if the -vv option is used e.g.</simpara>
<literallayout class="monospaced">mmap length 528384
auxtrace mmap length 4198400</literallayout>
</refsect2>
<refsect2 id="_intel_pt_modes_of_operation">
<title>Intel PT modes of operation</title>
<simpara>Intel PT can be used in 3 modes:
        full-trace mode
        sample mode
        snapshot mode</simpara>
<simpara>Full-trace mode traces continuously e.g.</simpara>
<literallayout class="monospaced">perf record -e intel_pt//u uname</literallayout>
<simpara>Sample mode attaches a Intel PT sample to other events e.g.</simpara>
<literallayout class="monospaced">perf record --aux-sample -e intel_pt//u -e branch-misses:u</literallayout>
<simpara>Snapshot mode captures the available data when a signal is sent or "snapshot"
control command is issued. e.g. using a signal</simpara>
<literallayout class="monospaced">perf record -v -e intel_pt//u -S ./loopy 1000000000 &amp;
[1] 11435
kill -USR2 11435
Recording AUX area tracing snapshot</literallayout>
<simpara>Note that the signal sent is SIGUSR2.
Note that "Recording AUX area tracing snapshot" is displayed because the -v
option is used.</simpara>
<simpara>The advantage of using "snapshot" control command is that the access is
controlled by access to a FIFO e.g.</simpara>
<literallayout class="monospaced">$ mkfifo perf.control
$ mkfifo perf.ack
$ cat perf.ack &amp;
[1] 15235
$ sudo ~/bin/perf record --control fifo:perf.control,perf.ack -S -e intel_pt//u -- sleep 60 &amp;
[2] 15243
$ ps -e | grep perf
15244 pts/1    00:00:00 perf
$ kill -USR2 15244
bash: kill: (15244) - Operation not permitted
$ echo snapshot &gt; perf.control
ack</literallayout>
<simpara>The 3 Intel PT modes of operation cannot be used together.</simpara>
</refsect2>
<refsect2 id="_buffer_handling">
<title>Buffer handling</title>
<simpara>There may be buffer limitations (i.e. single ToPa entry) which means that actual
buffer sizes are limited to powers of 2 up to 4MiB (MAX_ORDER).  In order to
provide other sizes, and in particular an arbitrarily large size, multiple
buffers are logically concatenated.  However an interrupt must be used to switch
between buffers.  That has two potential problems:
        a) the interrupt may not be handled in time so that the current buffer
        becomes full and some trace data is lost.
        b) the interrupts may slow the system and affect the performance
        results.</simpara>
<simpara>If trace data is lost, the driver sets <emphasis>truncated</emphasis> in the PERF_RECORD_AUX event
which the tools report as an error.</simpara>
<simpara>In full-trace mode, the driver waits for data to be copied out before allowing
the (logical) buffer to wrap-around.  If data is not copied out quickly enough,
again <emphasis>truncated</emphasis> is set in the PERF_RECORD_AUX event.  If the driver has to
wait, the intel_pt event gets disabled.  Because it is difficult to know when
that happens, perf tools always re-enable the intel_pt event after copying out
data.</simpara>
</refsect2>
<refsect2 id="_intel_pt_and_build_ids">
<title>Intel PT and build ids</title>
<simpara>By default "perf record" post-processes the event stream to find all build ids
for executables for all addresses sampled.  Deliberately, Intel PT is not
decoded for that purpose (it would take too long).  Instead the build ids for
all executables encountered (due to mmap, comm or task events) are included
in the perf.data file.</simpara>
<simpara>To see buildids included in the perf.data file use the command:</simpara>
<literallayout class="monospaced">perf buildid-list</literallayout>
<simpara>If the perf.data file contains Intel PT data, that is the same as:</simpara>
<literallayout class="monospaced">perf buildid-list --with-hits</literallayout>
</refsect2>
<refsect2 id="_snapshot_mode_and_event_disabling">
<title>Snapshot mode and event disabling</title>
<simpara>In order to make a snapshot, the intel_pt event is disabled using an IOCTL,
namely PERF_EVENT_IOC_DISABLE.  However doing that can also disable the
collection of side-band information.  In order to prevent that,  a dummy
software event has been introduced that permits tracking events (like mmaps) to
continue to be recorded while intel_pt is disabled.  That is important to ensure
there is complete side-band information to allow the decoding of subsequent
snapshots.</simpara>
<simpara>A test has been created for that.  To find the test:</simpara>
<literallayout class="monospaced">perf test list
...
23: Test using a dummy software event to keep tracking</literallayout>
<simpara>To run the test:</simpara>
<literallayout class="monospaced">perf test 23
23: Test using a dummy software event to keep tracking     : Ok</literallayout>
</refsect2>
<refsect2 id="_perf_record_modes_nothing_new_here">
<title>perf record modes (nothing new here)</title>
<simpara>perf record essentially operates in one of three modes:
        per thread
        per cpu
        workload only</simpara>
<simpara>"per thread" mode is selected by -t or by --per-thread (with -p or -u or just a
workload).
"per cpu" is selected by -C or -a.
"workload only" mode is selected by not using the other options but providing a
command to run (i.e. the workload).</simpara>
<simpara>In per-thread mode an exact list of threads is traced.  There is no inheritance.
Each thread has its own event buffer.</simpara>
<simpara>In per-cpu mode all processes (or processes from the selected cgroup i.e. -G
option, or processes selected with -p or -u) are traced.  Each cpu has its own
buffer. Inheritance is allowed.</simpara>
<simpara>In workload-only mode, the workload is traced but with per-cpu buffers.
Inheritance is allowed.  Note that you can now trace a workload in per-thread
mode by using the --per-thread option.</simpara>
</refsect2>
<refsect2 id="_privileged_vs_non_privileged_users">
<title>Privileged vs non-privileged users</title>
<simpara>Unless /proc/sys/kernel/perf_event_paranoid is set to -1, unprivileged users
have memory limits imposed upon them.  That affects what buffer sizes they can
have as outlined above.</simpara>
<simpara>The v4.2 kernel introduced support for a context switch metadata event,
PERF_RECORD_SWITCH, which allows unprivileged users to see when their processes
are scheduled out and in, just not by whom, which is left for the
PERF_RECORD_SWITCH_CPU_WIDE, that is only accessible in system wide context,
which in turn requires CAP_PERFMON or CAP_SYS_ADMIN.</simpara>
<simpara>Please see the 45ac1403f564 ("perf: Add PERF_RECORD_SWITCH to indicate context
switches") commit, that introduces these metadata events for further info.</simpara>
<simpara>When working with kernels &lt; v4.2, the following considerations must be taken,
as the sched:sched_switch tracepoints will be used to receive such information:</simpara>
<simpara>Unless /proc/sys/kernel/perf_event_paranoid is set to -1, unprivileged users are
not permitted to use tracepoints which means there is insufficient side-band
information to decode Intel PT in per-cpu mode, and potentially workload-only
mode too if the workload creates new processes.</simpara>
<simpara>Note also, that to use tracepoints, read-access to debugfs is required.  So if
debugfs is not mounted or the user does not have read-access, it will again not
be possible to decode Intel PT in per-cpu mode.</simpara>
</refsect2>
<refsect2 id="_sched_switch_tracepoint">
<title>sched_switch tracepoint</title>
<simpara>The sched_switch tracepoint is used to provide side-band data for Intel PT
decoding in kernels where the PERF_RECORD_SWITCH metadata event isn&#8217;t
available.</simpara>
<simpara>The sched_switch events are automatically added. e.g. the second event shown
below:</simpara>
<literallayout class="monospaced">$ perf record -vv -e intel_pt//u uname
------------------------------------------------------------
perf_event_attr:
type                             6
size                             112
config                           0x400
{ sample_period, sample_freq }   1
sample_type                      IP|TID|TIME|CPU|IDENTIFIER
read_format                      ID
disabled                         1
inherit                          1
exclude_kernel                   1
exclude_hv                       1
enable_on_exec                   1
sample_id_all                    1
------------------------------------------------------------
sys_perf_event_open: pid 31104  cpu 0  group_fd -1  flags 0x8
sys_perf_event_open: pid 31104  cpu 1  group_fd -1  flags 0x8
sys_perf_event_open: pid 31104  cpu 2  group_fd -1  flags 0x8
sys_perf_event_open: pid 31104  cpu 3  group_fd -1  flags 0x8
------------------------------------------------------------
perf_event_attr:
type                             2
size                             112
config                           0x108
{ sample_period, sample_freq }   1
sample_type                      IP|TID|TIME|CPU|PERIOD|RAW|IDENTIFIER
read_format                      ID
inherit                          1
sample_id_all                    1
exclude_guest                    1
------------------------------------------------------------
sys_perf_event_open: pid -1  cpu 0  group_fd -1  flags 0x8
sys_perf_event_open: pid -1  cpu 1  group_fd -1  flags 0x8
sys_perf_event_open: pid -1  cpu 2  group_fd -1  flags 0x8
sys_perf_event_open: pid -1  cpu 3  group_fd -1  flags 0x8
------------------------------------------------------------
perf_event_attr:
type                             1
size                             112
config                           0x9
{ sample_period, sample_freq }   1
sample_type                      IP|TID|TIME|IDENTIFIER
read_format                      ID
disabled                         1
inherit                          1
exclude_kernel                   1
exclude_hv                       1
mmap                             1
comm                             1
enable_on_exec                   1
task                             1
sample_id_all                    1
mmap2                            1
comm_exec                        1
------------------------------------------------------------
sys_perf_event_open: pid 31104  cpu 0  group_fd -1  flags 0x8
sys_perf_event_open: pid 31104  cpu 1  group_fd -1  flags 0x8
sys_perf_event_open: pid 31104  cpu 2  group_fd -1  flags 0x8
sys_perf_event_open: pid 31104  cpu 3  group_fd -1  flags 0x8
mmap size 528384B
AUX area mmap length 4194304
perf event ring buffer mmapped per cpu
Synthesizing auxtrace information
Linux
[ perf record: Woken up 1 times to write data ]
[ perf record: Captured and wrote 0.042 MB perf.data ]</literallayout>
<simpara>Note, the sched_switch event is only added if the user is permitted to use it
and only in per-cpu mode.</simpara>
<simpara>Note also, the sched_switch event is only added if TSC packets are requested.
That is because, in the absence of timing information, the sched_switch events
cannot be matched against the Intel PT trace.</simpara>
</refsect2>
</refsect1>
<refsect1 id="_perf_script">
<title>perf script</title>
<simpara>By default, perf script will decode trace data found in the perf.data file.
This can be further controlled by new option --itrace.</simpara>
<refsect2 id="_new_itrace_option">
<title>New --itrace option</title>
<simpara>Having no option is the same as</simpara>
<literallayout class="monospaced">--itrace</literallayout>
<simpara>which, in turn, is the same as</simpara>
<literallayout class="monospaced">--itrace=cepwx</literallayout>
<simpara>The letters are:</simpara>
<literallayout class="monospaced">i       synthesize "instructions" events
b       synthesize "branches" events
x       synthesize "transactions" events
w       synthesize "ptwrite" events
p       synthesize "power" events (incl. PSB events)
c       synthesize branches events (calls only)
r       synthesize branches events (returns only)
e       synthesize tracing error events
d       create a debug log
g       synthesize a call chain (use with i or x)
G       synthesize a call chain on existing event records
l       synthesize last branch entries (use with i or x)
L       synthesize last branch entries on existing event records
s       skip initial number of events
q       quicker (less detailed) decoding
A       approximate IPC
Z       prefer to ignore timestamps (so-called "timeless" decoding)</literallayout>
<simpara>"Instructions" events look like they were recorded by "perf record -e
instructions".</simpara>
<simpara>"Branches" events look like they were recorded by "perf record -e branches". "c"
and "r" can be combined to get calls and returns.</simpara>
<simpara>"Transactions" events correspond to the start or end of transactions. The
<emphasis>flags</emphasis> field can be used in perf script to determine whether the event is a
transaction start, commit or abort.</simpara>
<simpara>Note that "instructions", "branches" and "transactions" events depend on code
flow packets which can be disabled by using the config term "branch=0".  Refer
to the config terms section above.</simpara>
<simpara>"ptwrite" events record the payload of the ptwrite instruction and whether
"fup_on_ptw" was used.  "ptwrite" events depend on PTWRITE packets which are
recorded only if the "ptw" config term was used.  Refer to the config terms
section above.  perf script "synth" field displays "ptwrite" information like
this: "ip: 0 payload: 0x123456789abcdef0"  where "ip" is 1 if "fup_on_ptw" was
used.</simpara>
<simpara>"Power" events correspond to power event packets and CBR (core-to-bus ratio)
packets.  While CBR packets are always recorded when tracing is enabled, power
event packets are recorded only if the "pwr_evt" config term was used.  Refer to
the config terms section above.  The power events record information about
C-state changes, whereas CBR is indicative of CPU frequency.  perf script
"event,synth" fields display information like this:
        cbr:  cbr: 22 freq: 2189 MHz (200%)
        mwait:  hints: 0x60 extensions: 0x1
        pwre:  hw: 0 cstate: 2 sub-cstate: 0
        exstop:  ip: 1
        pwrx:  deepest cstate: 2 last cstate: 2 wake reason: 0x4
Where:
        "cbr" includes the frequency and the percentage of maximum non-turbo
        "mwait" shows mwait hints and extensions
        "pwre" shows C-state transitions (to a C-state deeper than C0) and
        whether initiated by hardware
        "exstop" indicates execution stopped and whether the IP was recorded
        exactly,
        "pwrx" indicates return to C0
For more details refer to the Intel 64 and IA-32 Architectures Software
Developer Manuals.</simpara>
<simpara>PSB events show when a PSB+ occurred and also the byte-offset in the trace.
Emitting a PSB+ can cause a CPU a slight delay. When doing timing analysis
of code with Intel PT, it is useful to know if a timing bubble was caused
by Intel PT or not.</simpara>
<simpara>Error events show where the decoder lost the trace.  Error events
are quite important.  Users must know if what they are seeing is a complete
picture or not. The "e" option may be followed by flags which affect what errors
will or will not be reported.  Each flag must be preceded by either <emphasis>+</emphasis> or <emphasis>-</emphasis>.
The flags supported by Intel PT are:
                -o      Suppress overflow errors
                -l      Suppress trace data lost errors
For example, for errors but not overflow or data lost errors:</simpara>
<literallayout class="monospaced">--itrace=e-o-l</literallayout>
<simpara>The "d" option will cause the creation of a file "intel_pt.log" containing all
decoded packets and instructions.  Note that this option slows down the decoder
and that the resulting file may be very large.  The "d" option may be followed
by flags which affect what debug messages will or will not be logged. Each flag
must be preceded by either <emphasis>+</emphasis> or <emphasis>-</emphasis>. The flags support by Intel PT are:
                -a      Suppress logging of perf events
                +a      Log all perf events
                +o      Output to stdout instead of "intel_pt.log"
By default, logged perf events are filtered by any specified time ranges, but
flag +a overrides that.</simpara>
<simpara>In addition, the period of the "instructions" event can be specified. e.g.</simpara>
<literallayout class="monospaced">--itrace=i10us</literallayout>
<simpara>sets the period to 10us i.e. one  instruction sample is synthesized for each 10
microseconds of trace.  Alternatives to "us" are "ms" (milliseconds),
"ns" (nanoseconds), "t" (TSC ticks) or "i" (instructions).</simpara>
<simpara>"ms", "us" and "ns" are converted to TSC ticks.</simpara>
<simpara>The timing information included with Intel PT does not give the time of every
instruction.  Consequently, for the purpose of sampling, the decoder estimates
the time since the last timing packet based on 1 tick per instruction.  The time
on the sample is <emphasis role="strong">not</emphasis> adjusted and reflects the last known value of TSC.</simpara>
<simpara>For Intel PT, the default period is 100us.</simpara>
<simpara>Setting it to a zero period means "as often as possible".</simpara>
<simpara>In the case of Intel PT that is the same as a period of 1 and a unit of
<emphasis>instructions</emphasis> (i.e. --itrace=i1i).</simpara>
<simpara>Also the call chain size (default 16, max. 1024) for instructions or
transactions events can be specified. e.g.</simpara>
<literallayout class="monospaced">--itrace=ig32
--itrace=xg32</literallayout>
<simpara>Also the number of last branch entries (default 64, max. 1024) for instructions or
transactions events can be specified. e.g.</simpara>
<literallayout class="monospaced">--itrace=il10
--itrace=xl10</literallayout>
<simpara>Note that last branch entries are cleared for each sample, so there is no overlap
from one sample to the next.</simpara>
<simpara>The G and L options are designed in particular for sample mode, and work much
like g and l but add call chain and branch stack to the other selected events
instead of synthesized events. For example, to record branch-misses events for
<emphasis>ls</emphasis> and then add a call chain derived from the Intel PT trace:</simpara>
<literallayout class="monospaced">perf record --aux-sample -e '{intel_pt//u,branch-misses:u}' -- ls
perf report --itrace=Ge</literallayout>
<simpara>Although in fact G is a default for perf report, so that is the same as just:</simpara>
<literallayout class="monospaced">perf report</literallayout>
<simpara>One caveat with the G and L options is that they work poorly with "Large PEBS".
Large PEBS means PEBS records will be accumulated by hardware and the written
into the event buffer in one go.  That reduces interrupts, but can give very
late timestamps.  Because the Intel PT trace is synchronized by timestamps,
the PEBS events do not match the trace.  Currently, Large PEBS is used only in
certain circumstances:
        - hardware supports it
        - PEBS is used
        - event period is specified, instead of frequency
        - the sample type is limited to the following flags:
                PERF_SAMPLE_IP | PERF_SAMPLE_TID | PERF_SAMPLE_ADDR |
                PERF_SAMPLE_ID | PERF_SAMPLE_CPU | PERF_SAMPLE_STREAM_ID |
                PERF_SAMPLE_DATA_SRC | PERF_SAMPLE_IDENTIFIER |
                PERF_SAMPLE_TRANSACTION | PERF_SAMPLE_PHYS_ADDR |
                PERF_SAMPLE_REGS_INTR | PERF_SAMPLE_REGS_USER |
                PERF_SAMPLE_PERIOD (and sometimes) | PERF_SAMPLE_TIME
Because Intel PT sample mode uses a different sample type to the list above,
Large PEBS is not used with Intel PT sample mode. To avoid Large PEBS in other
cases, avoid specifying the event period i.e. avoid the <emphasis>perf record</emphasis> -c option,
--count option, or <emphasis>period</emphasis> config term.</simpara>
<simpara>To disable trace decoding entirely, use the option --no-itrace.</simpara>
<simpara>It is also possible to skip events generated (instructions, branches, transactions)
at the beginning. This is useful to ignore initialization code.</simpara>
<literallayout class="monospaced">--itrace=i0nss1000000</literallayout>
<simpara>skips the first million instructions.</simpara>
<simpara>The q option changes the way the trace is decoded.  The decoding is much faster
but much less detailed.  Specifically, with the q option, the decoder does not
decode TNT packets, and does not walk object code, but gets the ip from FUP and
TIP packets.  The q option can be used with the b and i options but the period
is not used.  The q option decodes more quickly, but is useful only if the
control flow of interest is represented or indicated by FUP, TIP, TIP.PGE, or
TIP.PGD packets (refer below).  However the q option could be used to find time
ranges that could then be decoded fully using the --time option.</simpara>
<simpara>What will <emphasis role="strong">not</emphasis> be decoded with the (single) q option:</simpara>
<itemizedlist>
<listitem>
<simpara>
direct calls and jmps
</simpara>
</listitem>
<listitem>
<simpara>
conditional branches
</simpara>
</listitem>
<listitem>
<simpara>
non-branch instructions
</simpara>
</listitem>
</itemizedlist>
<simpara>What <emphasis role="strong">will</emphasis> be decoded with the (single) q option:</simpara>
<itemizedlist>
<listitem>
<simpara>
asynchronous branches such as interrupts
</simpara>
</listitem>
<listitem>
<simpara>
indirect branches
</simpara>
</listitem>
<listitem>
<simpara>
function return target address <emphasis role="strong">if</emphasis> the noretcomp config term (refer
        config terms section) was used
</simpara>
</listitem>
<listitem>
<simpara>
start of (control-flow) tracing
</simpara>
</listitem>
<listitem>
<simpara>
end of (control-flow) tracing, if it is not out of context
</simpara>
</listitem>
<listitem>
<simpara>
power events, ptwrite, transaction start and abort
</simpara>
</listitem>
<listitem>
<simpara>
instruction pointer associated with PSB packets
</simpara>
</listitem>
</itemizedlist>
<simpara>Note the q option does not specify what events will be synthesized e.g. the p
option must be used also to show power events.</simpara>
<simpara>Repeating the q option (double-q i.e. qq) results in even faster decoding and even
less detail.  The decoder decodes only extended PSB (PSB+) packets, getting the
instruction pointer if there is a FUP packet within PSB+ (i.e. between PSB and
PSBEND).  Note PSB packets occur regularly in the trace based on the psb_period
config term (refer config terms section).  There will be a FUP packet if the
PSB+ occurs while control flow is being traced.</simpara>
<simpara>What will <emphasis role="strong">not</emphasis> be decoded with the qq option:</simpara>
<itemizedlist>
<listitem>
<simpara>
everything except instruction pointer associated with PSB packets
</simpara>
</listitem>
</itemizedlist>
<simpara>What <emphasis role="strong">will</emphasis> be decoded with the qq option:</simpara>
<itemizedlist>
<listitem>
<simpara>
instruction pointer associated with PSB packets
</simpara>
</listitem>
</itemizedlist>
<simpara>The Z option is equivalent to having recorded a trace without TSC
(i.e. config term tsc=0). It can be useful to avoid timestamp issues when
decoding a trace of a virtual machine.</simpara>
</refsect2>
<refsect2 id="_dlfilter_show_cycles_so">
<title>dlfilter-show-cycles.so</title>
<simpara>Cycles can be displayed using dlfilter-show-cycles.so in which case the itrace A
option can be useful to provide higher granularity cycle information:</simpara>
<literallayout class="monospaced">perf script --itrace=A --call-trace --dlfilter dlfilter-show-cycles.so</literallayout>
<simpara>To see a list of dlfilters:</simpara>
<literallayout class="monospaced">perf script -v --list-dlfilters</literallayout>
<simpara>See also <citerefentry>
<refentrytitle>perf-dlfilters</refentrytitle><manvolnum>1</manvolnum>
</citerefentry></simpara>
</refsect2>
<refsect2 id="_dump_option">
<title>dump option</title>
<simpara>perf script has an option (-D) to "dump" the events i.e. display the binary
data.</simpara>
<simpara>When -D is used, Intel PT packets are displayed.  The packet decoder does not
pay attention to PSB packets, but just decodes the bytes - so the packets seen
by the actual decoder may not be identical in places where the data is corrupt.
One example of that would be when the buffer-switching interrupt has been too
slow, and the buffer has been filled completely.  In that case, the last packet
in the buffer might be truncated and immediately followed by a PSB as the trace
continues in the next buffer.</simpara>
<simpara>To disable the display of Intel PT packets, combine the -D option with
--no-itrace.</simpara>
</refsect2>
</refsect1>
<refsect1 id="_perf_report">
<title>perf report</title>
<simpara>By default, perf report will decode trace data found in the perf.data file.
This can be further controlled by new option --itrace exactly the same as
perf script, with the exception that the default is --itrace=igxe.</simpara>
</refsect1>
<refsect1 id="_perf_inject">
<title>perf inject</title>
<simpara>perf inject also accepts the --itrace option in which case tracing data is
removed and replaced with the synthesized events. e.g.</simpara>
<literallayout class="monospaced">perf inject --itrace -i perf.data -o perf.data.new</literallayout>
<simpara>Below is an example of using Intel PT with autofdo.  It requires autofdo
(<ulink url="https://github.com/google/autofdo">https://github.com/google/autofdo</ulink>) and gcc version 5.  The bubble
sort example is from the AutoFDO tutorial (<ulink url="https://gcc.gnu.org/wiki/AutoFDO/Tutorial">https://gcc.gnu.org/wiki/AutoFDO/Tutorial</ulink>)
amended to take the number of elements as a parameter.</simpara>
<literallayout class="monospaced">$ gcc-5 -O3 sort.c -o sort_optimized
$ ./sort_optimized 30000
Bubble sorting array of 30000 elements
2254 ms</literallayout>
<literallayout class="monospaced">$ cat ~/.perfconfig
[intel-pt]
        mispred-all = on</literallayout>
<literallayout class="monospaced">$ perf record -e intel_pt//u ./sort 3000
Bubble sorting array of 3000 elements
58 ms
[ perf record: Woken up 2 times to write data ]
[ perf record: Captured and wrote 3.939 MB perf.data ]
$ perf inject -i perf.data -o inj --itrace=i100usle --strip
$ ./create_gcov --binary=./sort --profile=inj --gcov=sort.gcov -gcov_version=1
$ gcc-5 -O3 -fauto-profile=sort.gcov sort.c -o sort_autofdo
$ ./sort_autofdo 30000
Bubble sorting array of 30000 elements
2155 ms</literallayout>
<simpara>Note there is currently no advantage to using Intel PT instead of LBR, but
that may change in the future if greater use is made of the data.</simpara>
</refsect1>
<refsect1 id="_pebs_via_intel_pt">
<title>PEBS via Intel PT</title>
<simpara>Some hardware has the feature to redirect PEBS records to the Intel PT trace.
Recording is selected by using the aux-output config term e.g.</simpara>
<literallayout class="monospaced">perf record -c 10000 -e '{intel_pt/branch=0/,cycles/aux-output/ppp}' uname</literallayout>
<simpara>Originally, software only supported redirecting at most one PEBS event because it
was not able to differentiate one event from another. To overcome that, more recent
kernels and perf tools add support for the PERF_RECORD_AUX_OUTPUT_HW_ID side-band event.
To check for the presence of that event in a PEBS-via-PT trace:</simpara>
<literallayout class="monospaced">perf script -D --no-itrace | grep PERF_RECORD_AUX_OUTPUT_HW_ID</literallayout>
<simpara>To display PEBS events from the Intel PT trace, use the itrace <emphasis>o</emphasis> option e.g.</simpara>
<literallayout class="monospaced">perf script --itrace=oe</literallayout>
</refsect1>
<refsect1 id="_xed">
<title>XED</title>
<simpara>For --xed the xed tool is needed. Here is how to install it:</simpara>
<literallayout class="monospaced">$ git clone https://github.com/intelxed/mbuild.git mbuild
$ git clone https://github.com/intelxed/xed
$ cd xed
$ ./mfile.py --share
$ ./mfile.py examples
$ sudo ./mfile.py --prefix=/usr/local install
$ sudo ldconfig
$ sudo cp obj/examples/xed /usr/local/bin</literallayout>
<simpara>Basic xed testing:</simpara>
<literallayout class="monospaced">$ xed | head -3
ERROR: required argument(s) were missing
Copyright (C) 2017, Intel Corporation. All rights reserved.
XED version: [v10.0-328-g7d62c8c49b7b]
$</literallayout>
</refsect1>
<refsect1 id="_tracing_virtual_machines">
<title>Tracing Virtual Machines</title>
<simpara>Currently, only kernel tracing is supported and only with either "timeless" decoding
(i.e. no TSC timestamps) or VM Time Correlation. VM Time Correlation is an extra step
using <emphasis>perf inject</emphasis> and requires unchanging VMX TSC Offset and no VMX TSC Scaling.</simpara>
<simpara>Other limitations and caveats</simpara>
<literallayout class="monospaced">VMX controls may suppress packets needed for decoding resulting in decoding errors
VMX controls may block the perf NMI to the host potentially resulting in lost trace data
Guest kernel self-modifying code (e.g. jump labels or JIT-compiled eBPF) will result in decoding errors
Guest thread information is unknown
Guest VCPU is unknown but may be able to be inferred from the host thread
Callchains are not supported</literallayout>
<simpara>Example using "timeless" decoding</simpara>
<simpara>Start VM</simpara>
<literallayout class="monospaced">$ sudo virsh start kubuntu20.04
Domain kubuntu20.04 started</literallayout>
<simpara>Mount the guest file system.  Note sshfs needs -o direct_io to enable reading of proc files.  root access is needed to read /proc/kcore.</simpara>
<literallayout class="monospaced">$ mkdir vm0
$ sshfs -o direct_io root@vm0:/ vm0</literallayout>
<simpara>Copy the guest /proc/kallsyms, /proc/modules and /proc/kcore</simpara>
<literallayout class="monospaced">$ perf buildid-cache -v --kcore vm0/proc/kcore
kcore added to build-id cache directory /home/user/.debug/[kernel.kcore]/9600f316a53a0f54278885e8d9710538ec5f6a08/2021021807494306
$ KALLSYMS=/home/user/.debug/[kernel.kcore]/9600f316a53a0f54278885e8d9710538ec5f6a08/2021021807494306/kallsyms</literallayout>
<simpara>Find the VM process</simpara>
<literallayout class="monospaced">$ ps -eLl | grep 'KVM\|PID'
F S   UID     PID    PPID     LWP  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
3 S 64055    1430       1    1440  1  80   0 - 1921718 -    ?        00:02:47 CPU 0/KVM
3 S 64055    1430       1    1441  1  80   0 - 1921718 -    ?        00:02:41 CPU 1/KVM
3 S 64055    1430       1    1442  1  80   0 - 1921718 -    ?        00:02:38 CPU 2/KVM
3 S 64055    1430       1    1443  2  80   0 - 1921718 -    ?        00:03:18 CPU 3/KVM</literallayout>
<simpara>Start an open-ended perf record, tracing the VM process, do something on the VM, and then ctrl-C to stop.
TSC is not supported and tsc=0 must be specified.  That means mtc is useless, so add mtc=0.
However, IPC can still be determined, hence cyc=1 can be added.
Only kernel decoding is supported, so <emphasis>k</emphasis> must be specified.
Intel PT traces both the host and the guest so --guest and --host need to be specified.
Without timestamps, --per-thread must be specified to distinguish threads.</simpara>
<literallayout class="monospaced">$ sudo perf kvm --guest --host --guestkallsyms $KALLSYMS record --kcore -e intel_pt/tsc=0,mtc=0,cyc=1/k -p 1430 --per-thread
^C
[ perf record: Woken up 1 times to write data ]
[ perf record: Captured and wrote 5.829 MB ]</literallayout>
<simpara>perf script can be used to provide an instruction trace</simpara>
<literallayout class="monospaced">$ perf script --guestkallsyms $KALLSYMS --insn-trace --xed -F+ipc | grep -C10 vmresume | head -21
      CPU 0/KVM  1440  ffffffff82133cdd __vmx_vcpu_run+0x3d ([kernel.kallsyms])                movq  0x48(%rax), %r9
      CPU 0/KVM  1440  ffffffff82133ce1 __vmx_vcpu_run+0x41 ([kernel.kallsyms])                movq  0x50(%rax), %r10
      CPU 0/KVM  1440  ffffffff82133ce5 __vmx_vcpu_run+0x45 ([kernel.kallsyms])                movq  0x58(%rax), %r11
      CPU 0/KVM  1440  ffffffff82133ce9 __vmx_vcpu_run+0x49 ([kernel.kallsyms])                movq  0x60(%rax), %r12
      CPU 0/KVM  1440  ffffffff82133ced __vmx_vcpu_run+0x4d ([kernel.kallsyms])                movq  0x68(%rax), %r13
      CPU 0/KVM  1440  ffffffff82133cf1 __vmx_vcpu_run+0x51 ([kernel.kallsyms])                movq  0x70(%rax), %r14
      CPU 0/KVM  1440  ffffffff82133cf5 __vmx_vcpu_run+0x55 ([kernel.kallsyms])                movq  0x78(%rax), %r15
      CPU 0/KVM  1440  ffffffff82133cf9 __vmx_vcpu_run+0x59 ([kernel.kallsyms])                movq  (%rax), %rax
      CPU 0/KVM  1440  ffffffff82133cfc __vmx_vcpu_run+0x5c ([kernel.kallsyms])                callq  0xffffffff82133c40
      CPU 0/KVM  1440  ffffffff82133c40 vmx_vmenter+0x0 ([kernel.kallsyms])            jz 0xffffffff82133c46
      CPU 0/KVM  1440  ffffffff82133c42 vmx_vmenter+0x2 ([kernel.kallsyms])            vmresume         IPC: 0.11 (50/445)
          :1440  1440  ffffffffbb678b06 native_write_msr+0x6 ([guest.kernel.kallsyms])                 nopl  %eax, (%rax,%rax,1)
          :1440  1440  ffffffffbb678b0b native_write_msr+0xb ([guest.kernel.kallsyms])                 retq     IPC: 0.04 (2/41)
          :1440  1440  ffffffffbb666646 lapic_next_deadline+0x26 ([guest.kernel.kallsyms])             data16 nop
          :1440  1440  ffffffffbb666648 lapic_next_deadline+0x28 ([guest.kernel.kallsyms])             xor %eax, %eax
          :1440  1440  ffffffffbb66664a lapic_next_deadline+0x2a ([guest.kernel.kallsyms])             popq  %rbp
          :1440  1440  ffffffffbb66664b lapic_next_deadline+0x2b ([guest.kernel.kallsyms])             retq     IPC: 0.16 (4/25)
          :1440  1440  ffffffffbb74607f clockevents_program_event+0x8f ([guest.kernel.kallsyms])               test %eax, %eax
          :1440  1440  ffffffffbb746081 clockevents_program_event+0x91 ([guest.kernel.kallsyms])               jz 0xffffffffbb74603c    IPC: 0.06 (2/30)
          :1440  1440  ffffffffbb74603c clockevents_program_event+0x4c ([guest.kernel.kallsyms])               popq  %rbx
          :1440  1440  ffffffffbb74603d clockevents_program_event+0x4d ([guest.kernel.kallsyms])               popq  %r12</literallayout>
<simpara>Example using VM Time Correlation</simpara>
<simpara>Start VM</simpara>
<literallayout class="monospaced">$ sudo virsh start kubuntu20.04
Domain kubuntu20.04 started</literallayout>
<simpara>Mount the guest file system.  Note sshfs needs -o direct_io to enable reading of proc files.  root access is needed to read /proc/kcore.</simpara>
<literallayout class="monospaced">$ mkdir -p vm0
$ sshfs -o direct_io root@vm0:/ vm0</literallayout>
<simpara>Copy the guest /proc/kallsyms, /proc/modules and /proc/kcore</simpara>
<literallayout class="monospaced">$ perf buildid-cache -v --kcore vm0/proc/kcore
same kcore found in /home/user/.debug/[kernel.kcore]/cc9c55a98c5e4ec0aeda69302554aabed5cd6491/2021021312450777
$ KALLSYMS=/home/user/.debug/\[kernel.kcore\]/cc9c55a98c5e4ec0aeda69302554aabed5cd6491/2021021312450777/kallsyms</literallayout>
<simpara>Find the VM process</simpara>
<literallayout class="monospaced">$ ps -eLl | grep 'KVM\|PID'
F S   UID     PID    PPID     LWP  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
3 S 64055   16998       1   17005 13  80   0 - 1818189 -    ?        00:00:16 CPU 0/KVM
3 S 64055   16998       1   17006  4  80   0 - 1818189 -    ?        00:00:05 CPU 1/KVM
3 S 64055   16998       1   17007  3  80   0 - 1818189 -    ?        00:00:04 CPU 2/KVM
3 S 64055   16998       1   17008  4  80   0 - 1818189 -    ?        00:00:05 CPU 3/KVM</literallayout>
<simpara>Start an open-ended perf record, tracing the VM process, do something on the VM, and then ctrl-C to stop.
IPC can be determined, hence cyc=1 can be added.
Only kernel decoding is supported, so <emphasis>k</emphasis> must be specified.
Intel PT traces both the host and the guest so --guest and --host need to be specified.</simpara>
<literallayout class="monospaced">$ sudo perf kvm --guest --host --guestkallsyms $KALLSYMS record --kcore -e intel_pt/cyc=1/k -p 16998
^C[ perf record: Woken up 1 times to write data ]
[ perf record: Captured and wrote 9.041 MB perf.data.kvm ]</literallayout>
<simpara>Now <emphasis>perf inject</emphasis> can be used to determine the VMX TCS Offset. Note, Intel PT TSC packets are
only 7-bytes, so the TSC Offset might differ from the actual value in the 8th byte. That will
have no effect i.e. the resulting timestamps will be correct anyway.</simpara>
<literallayout class="monospaced">$ perf inject -i perf.data.kvm --vm-time-correlation=dry-run
ERROR: Unknown TSC Offset for VMCS 0x1bff6a
VMCS: 0x1bff6a  TSC Offset 0xffffe42722c64c41
ERROR: Unknown TSC Offset for VMCS 0x1cbc08
VMCS: 0x1cbc08  TSC Offset 0xffffe42722c64c41
ERROR: Unknown TSC Offset for VMCS 0x1c3ce8
VMCS: 0x1c3ce8  TSC Offset 0xffffe42722c64c41
ERROR: Unknown TSC Offset for VMCS 0x1cbce9
VMCS: 0x1cbce9  TSC Offset 0xffffe42722c64c41</literallayout>
<simpara>Each virtual CPU has a different Virtual Machine Control Structure (VMCS)
shown above with the calculated TSC Offset. For an unchanging TSC Offset
they should all be the same for the same virtual machine.</simpara>
<simpara>Now that the TSC Offset is known, it can be provided to <emphasis>perf inject</emphasis></simpara>
<literallayout class="monospaced">$ perf inject -i perf.data.kvm --vm-time-correlation="dry-run 0xffffe42722c64c41"</literallayout>
<simpara>Note the options for <emphasis>perf inject</emphasis> --vm-time-correlation are:</simpara>
<literallayout class="monospaced">[ dry-run ] [ &lt;TSC Offset&gt; [ : &lt;VMCS&gt; [ , &lt;VMCS&gt; ]... ]  ]...</literallayout>
<simpara>So it is possible to specify different TSC Offsets for different VMCS.
The option "dry-run" will cause the file to be processed but without updating it.
Note it is also possible to get a intel_pt.log file by adding option --itrace=d</simpara>
<simpara>There were no errors so, do it for real</simpara>
<literallayout class="monospaced">$ perf inject -i perf.data.kvm --vm-time-correlation=0xffffe42722c64c41 --force</literallayout>
<simpara><emphasis>perf script</emphasis> can be used to see if there are any decoder errors</simpara>
<literallayout class="monospaced">$ perf script -i perf.data.kvm --guestkallsyms $KALLSYMS --itrace=e-o</literallayout>
<simpara>There were none.</simpara>
<simpara><emphasis>perf script</emphasis> can be used to provide an instruction trace showing timestamps</simpara>
<literallayout class="monospaced">$ perf script -i perf.data.kvm --guestkallsyms $KALLSYMS --insn-trace --xed -F+ipc | grep -C10 vmresume | head -21
      CPU 1/KVM 17006 [001] 11500.262865593:  ffffffff82133cdd __vmx_vcpu_run+0x3d ([kernel.kallsyms])                 movq  0x48(%rax), %r9
      CPU 1/KVM 17006 [001] 11500.262865593:  ffffffff82133ce1 __vmx_vcpu_run+0x41 ([kernel.kallsyms])                 movq  0x50(%rax), %r10
      CPU 1/KVM 17006 [001] 11500.262865593:  ffffffff82133ce5 __vmx_vcpu_run+0x45 ([kernel.kallsyms])                 movq  0x58(%rax), %r11
      CPU 1/KVM 17006 [001] 11500.262865593:  ffffffff82133ce9 __vmx_vcpu_run+0x49 ([kernel.kallsyms])                 movq  0x60(%rax), %r12
      CPU 1/KVM 17006 [001] 11500.262865593:  ffffffff82133ced __vmx_vcpu_run+0x4d ([kernel.kallsyms])                 movq  0x68(%rax), %r13
      CPU 1/KVM 17006 [001] 11500.262865593:  ffffffff82133cf1 __vmx_vcpu_run+0x51 ([kernel.kallsyms])                 movq  0x70(%rax), %r14
      CPU 1/KVM 17006 [001] 11500.262865593:  ffffffff82133cf5 __vmx_vcpu_run+0x55 ([kernel.kallsyms])                 movq  0x78(%rax), %r15
      CPU 1/KVM 17006 [001] 11500.262865593:  ffffffff82133cf9 __vmx_vcpu_run+0x59 ([kernel.kallsyms])                 movq  (%rax), %rax
      CPU 1/KVM 17006 [001] 11500.262865593:  ffffffff82133cfc __vmx_vcpu_run+0x5c ([kernel.kallsyms])                 callq  0xffffffff82133c40
      CPU 1/KVM 17006 [001] 11500.262865593:  ffffffff82133c40 vmx_vmenter+0x0 ([kernel.kallsyms])             jz 0xffffffff82133c46
      CPU 1/KVM 17006 [001] 11500.262866075:  ffffffff82133c42 vmx_vmenter+0x2 ([kernel.kallsyms])             vmresume         IPC: 0.05 (40/769)
         :17006 17006 [001] 11500.262869216:  ffffffff82200cb0 asm_sysvec_apic_timer_interrupt+0x0 ([guest.kernel.kallsyms])           clac
         :17006 17006 [001] 11500.262869216:  ffffffff82200cb3 asm_sysvec_apic_timer_interrupt+0x3 ([guest.kernel.kallsyms])           pushq  $0xffffffffffffffff
         :17006 17006 [001] 11500.262869216:  ffffffff82200cb5 asm_sysvec_apic_timer_interrupt+0x5 ([guest.kernel.kallsyms])           callq  0xffffffff82201160
         :17006 17006 [001] 11500.262869216:  ffffffff82201160 error_entry+0x0 ([guest.kernel.kallsyms])               cld
         :17006 17006 [001] 11500.262869216:  ffffffff82201161 error_entry+0x1 ([guest.kernel.kallsyms])               pushq  %rsi
         :17006 17006 [001] 11500.262869216:  ffffffff82201162 error_entry+0x2 ([guest.kernel.kallsyms])               movq  0x8(%rsp), %rsi
         :17006 17006 [001] 11500.262869216:  ffffffff82201167 error_entry+0x7 ([guest.kernel.kallsyms])               movq  %rdi, 0x8(%rsp)
         :17006 17006 [001] 11500.262869216:  ffffffff8220116c error_entry+0xc ([guest.kernel.kallsyms])               pushq  %rdx
         :17006 17006 [001] 11500.262869216:  ffffffff8220116d error_entry+0xd ([guest.kernel.kallsyms])               pushq  %rcx
         :17006 17006 [001] 11500.262869216:  ffffffff8220116e error_entry+0xe ([guest.kernel.kallsyms])               pushq  %rax</literallayout>
</refsect1>
<refsect1 id="_see_also">
<title>SEE ALSO</title>
<simpara><citerefentry>
<refentrytitle>perf-record</refentrytitle><manvolnum>1</manvolnum>
</citerefentry>, <citerefentry>
<refentrytitle>perf-script</refentrytitle><manvolnum>1</manvolnum>
</citerefentry>, <citerefentry>
<refentrytitle>perf-report</refentrytitle><manvolnum>1</manvolnum>
</citerefentry>,
<citerefentry>
<refentrytitle>perf-inject</refentrytitle><manvolnum>1</manvolnum>
</citerefentry></simpara>
</refsect1>
</refentry>
