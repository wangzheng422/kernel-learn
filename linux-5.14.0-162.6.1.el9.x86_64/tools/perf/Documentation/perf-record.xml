<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<?asciidoc-toc?>
<?asciidoc-numbered?>
<refentry>
<refentryinfo><date></date></refentryinfo>
<refmeta>
<refentrytitle>perf-record</refentrytitle>
<manvolnum>1</manvolnum>
<refmiscinfo class="source">perf</refmiscinfo>
<refmiscinfo class="version"></refmiscinfo>
<refmiscinfo class="manual">perf Manual</refmiscinfo>
</refmeta>
<refnamediv>
  <refname>perf-record</refname>
  <refpurpose>Run a command and record its profile into perf.data</refpurpose>
</refnamediv>
<refsynopsisdiv id="_synopsis">
<blockquote>
<literallayout><emphasis>perf record</emphasis> [-e &lt;EVENT&gt; | --event=EVENT] [-a] &lt;command&gt;
<emphasis>perf record</emphasis> [-e &lt;EVENT&gt; | --event=EVENT] [-a] -- &lt;command&gt; [&lt;options&gt;]</literallayout>
</blockquote>
</refsynopsisdiv>
<refsect1 id="_description">
<title>DESCRIPTION</title>
<simpara>This command runs a command and gathers a performance counter profile
from it, into perf.data - without displaying anything.</simpara>
<simpara>This file can then be inspected later on, using <emphasis>perf report</emphasis>.</simpara>
</refsect1>
<refsect1 id="_options">
<title>OPTIONS</title>
<variablelist>
<varlistentry>
<term>
&lt;command&gt;&#8230;
</term>
<listitem>
<simpara>
        Any command you can specify in a shell.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
-e
</term>
<term>
--event=
</term>
<listitem>
<simpara>
        Select the PMU event. Selection can be:
</simpara>
<itemizedlist>
<listitem>
<simpara>
a symbolic event name (use <emphasis>perf list</emphasis> to list all events)
</simpara>
</listitem>
<listitem>
<simpara>
a raw PMU event in the form of rN where N is a hexadecimal value
          that represents the raw register encoding with the layout of the
          event control registers as described by entries in
          /sys/bus/event_sources/devices/cpu/format/*.
</simpara>
</listitem>
<listitem>
<simpara>
a symbolic or raw PMU event followed by an optional colon
          and a list of event modifiers, e.g., cpu-cycles:p.  See the
          <citerefentry>
<refentrytitle>perf-list</refentrytitle><manvolnum>1</manvolnum>
</citerefentry> man page for details on event modifiers.
</simpara>
</listitem>
<listitem>
<simpara>
a symbolically formed PMU event like <emphasis>pmu/param1=0x3,param2/</emphasis> where
          <emphasis>param1</emphasis>, <emphasis>param2</emphasis>, etc are defined as formats for the PMU in
          /sys/bus/event_source/devices/&lt;pmu&gt;/format/*.
</simpara>
</listitem>
<listitem>
<simpara>
a symbolically formed event like <emphasis>pmu/config=M,config1=N,config3=K/</emphasis>
</simpara>
<literallayout class="monospaced">where M, N, K are numbers (in decimal, hex, octal format). Acceptable
values for each of 'config', 'config1' and 'config2' are defined by
corresponding entries in /sys/bus/event_source/devices/&lt;pmu&gt;/format/*
param1 and param2 are defined as formats for the PMU in:
/sys/bus/event_source/devices/&lt;pmu&gt;/format/*</literallayout>
<literallayout class="monospaced">There are also some parameters which are not defined in .../&lt;pmu&gt;/format/*.
These params can be used to overload default config values per event.
Here are some common parameters:
- 'period': Set event sampling period
- 'freq': Set event sampling frequency
- 'time': Disable/enable time stamping. Acceptable values are 1 for
          enabling time stamping. 0 for disabling time stamping.
          The default is 1.
- 'call-graph': Disable/enable callgraph. Acceptable str are "fp" for
               FP mode, "dwarf" for DWARF mode, "lbr" for LBR mode and
               "no" for disable callgraph.
- 'stack-size': user stack size for dwarf mode
- 'name' : User defined event name. Single quotes (') may be used to
          escape symbols in the name from parsing by shell and tool
          like this: name=\'CPU_CLK_UNHALTED.THREAD:cmask=0x1\'.
- 'aux-output': Generate AUX records instead of events. This requires
                that an AUX area event is also provided.
- 'aux-sample-size': Set sample size for AUX area sampling. If the
'--aux-sample' option has been used, set aux-sample-size=0 to disable
AUX area sampling for the event.</literallayout>
<literallayout class="monospaced">See the linkperf:perf-list[1] man page for more parameters.</literallayout>
<literallayout class="monospaced">Note: If user explicitly sets options which conflict with the params,
the value set by the parameters will be overridden.</literallayout>
<literallayout class="monospaced">Also not defined in .../&lt;pmu&gt;/format/* are PMU driver specific
configuration parameters.  Any configuration parameter preceded by
the letter '@' is not interpreted in user space and sent down directly
to the PMU driver.  For example:</literallayout>
<literallayout class="monospaced">perf record -e some_event/@cfg1,@cfg2=config/ ...</literallayout>
<literallayout class="monospaced">will see 'cfg1' and 'cfg2=config' pushed to the PMU driver associated
with the event for further processing.  There is no restriction on
what the configuration parameters are, as long as their semantic is
understood and supported by the PMU driver.</literallayout>
</listitem>
<listitem>
<simpara>
a hardware breakpoint event in the form of <emphasis>\mem:addr[/len][:access]</emphasis>
          where addr is the address in memory you want to break in.
          Access is the memory access type (read, write, execute) it can
          be passed as follows: <emphasis>\mem:addr[:[r][w][x]]</emphasis>. len is the range,
          number of bytes from specified addr, which the breakpoint will cover.
          If you want to profile read-write accesses in 0x1000, just set
          <emphasis>mem:0x1000:rw</emphasis>.
          If you want to profile write accesses in [0x1000~1008), just set
          <emphasis>mem:0x1000/8:w</emphasis>.
</simpara>
</listitem>
<listitem>
<simpara>
a BPF source file (ending in .c) or a precompiled object file (ending
          in .o) selects one or more BPF events.
          The BPF program can attach to various perf events based on the ELF section
          names.
</simpara>
<literallayout class="monospaced">When processing a '.c' file, perf searches an installed LLVM to compile it
into an object file first. Optional clang options can be passed via the
'--clang-opt' command line option, e.g.:</literallayout>
<literallayout class="monospaced">perf record --clang-opt "-DLINUX_VERSION_CODE=0x50000" \
            -e tests/bpf-script-example.c</literallayout>
<literallayout class="monospaced">Note: '--clang-opt' must be placed before '--event/-e'.</literallayout>
</listitem>
<listitem>
<simpara>
a group of events surrounded by a pair of brace ("{event1,event2,&#8230;}").
          Each event is separated by commas and the group should be quoted to
          prevent the shell interpretation.  You also need to use --group on
          "perf report" to view group events together.
</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>
--filter=&lt;filter&gt;
</term>
<listitem>
<simpara>
        Event filter. This option should follow an event selector (-e) which
        selects either tracepoint event(s) or a hardware trace PMU
        (e.g. Intel PT or CoreSight).
</simpara>
<itemizedlist>
<listitem>
<simpara>
tracepoint filters
</simpara>
<literallayout class="monospaced">In the case of tracepoints, multiple '--filter' options are combined
using '&amp;&amp;'.</literallayout>
</listitem>
<listitem>
<simpara>
address filters
</simpara>
<literallayout class="monospaced">A hardware trace PMU advertises its ability to accept a number of
address filters by specifying a non-zero value in
/sys/bus/event_source/devices/&lt;pmu&gt;/nr_addr_filters.</literallayout>
<literallayout class="monospaced">Address filters have the format:</literallayout>
<literallayout class="monospaced">filter|start|stop|tracestop &lt;start&gt; [/ &lt;size&gt;] [@&lt;file name&gt;]</literallayout>
<literallayout class="monospaced">Where:
- 'filter': defines a region that will be traced.
- 'start': defines an address at which tracing will begin.
- 'stop': defines an address at which tracing will stop.
- 'tracestop': defines a region in which tracing will stop.</literallayout>
<literallayout class="monospaced">&lt;file name&gt; is the name of the object file, &lt;start&gt; is the offset to the
code to trace in that file, and &lt;size&gt; is the size of the region to
trace. 'start' and 'stop' filters need not specify a &lt;size&gt;.</literallayout>
<literallayout class="monospaced">If no object file is specified then the kernel is assumed, in which case
the start address must be a current kernel memory address.</literallayout>
<literallayout class="monospaced">&lt;start&gt; can also be specified by providing the name of a symbol. If the
symbol name is not unique, it can be disambiguated by inserting #n where
'n' selects the n'th symbol in address order. Alternately #0, #g or #G
select only a global symbol. &lt;size&gt; can also be specified by providing
the name of a symbol, in which case the size is calculated to the end
of that symbol. For 'filter' and 'tracestop' filters, if &lt;size&gt; is
omitted and &lt;start&gt; is a symbol, then the size is calculated to the end
of that symbol.</literallayout>
<literallayout class="monospaced">If &lt;size&gt; is omitted and &lt;start&gt; is '*', then the start and size will
be calculated from the first and last symbols, i.e. to trace the whole
file.</literallayout>
<literallayout class="monospaced">If symbol names (or '*') are provided, they must be surrounded by white
space.</literallayout>
<literallayout class="monospaced">The filter passed to the kernel is not necessarily the same as entered.
To see the filter that is passed, use the -v option.</literallayout>
<literallayout class="monospaced">The kernel may not be able to configure a trace region if it is not
within a single mapping.  MMAP events (or /proc/&lt;pid&gt;/maps) can be
examined to determine if that is a possibility.</literallayout>
<literallayout class="monospaced">Multiple filters can be separated with space or comma.</literallayout>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>
--exclude-perf
</term>
<listitem>
<simpara>
        Don&#8217;t record events issued by perf itself. This option should follow
        an event selector (-e) which selects tracepoint event(s). It adds a
        filter expression <emphasis>common_pid != $PERFPID</emphasis> to filters. If other
        <emphasis>--filter</emphasis> exists, the new filter expression will be combined with
        them by <emphasis>&amp;&amp;</emphasis>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
-a
</term>
<term>
--all-cpus
</term>
<listitem>
<simpara>
        System-wide collection from all CPUs (default if no target is specified).
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
-p
</term>
<term>
--pid=
</term>
<listitem>
<simpara>
        Record events on existing process ID (comma separated list).
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
-t
</term>
<term>
--tid=
</term>
<listitem>
<simpara>
        Record events on existing thread ID (comma separated list).
        This option also disables inheritance by default.  Enable it by adding
        --inherit.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
-u
</term>
<term>
--uid=
</term>
<listitem>
<simpara>
        Record events in threads owned by uid. Name or number.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
-r
</term>
<term>
--realtime=
</term>
<listitem>
<simpara>
        Collect data with this RT SCHED_FIFO priority.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
--no-buffering
</term>
<listitem>
<simpara>
        Collect data without buffering.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
-c
</term>
<term>
--count=
</term>
<listitem>
<simpara>
        Event period to sample.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
-o
</term>
<term>
--output=
</term>
<listitem>
<simpara>
        Output file name.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
-i
</term>
<term>
--no-inherit
</term>
<listitem>
<simpara>
        Child tasks do not inherit counters.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
-F
</term>
<term>
--freq=
</term>
<listitem>
<simpara>
        Profile at this frequency. Use <emphasis>max</emphasis> to use the currently maximum
        allowed frequency, i.e. the value in the kernel.perf_event_max_sample_rate
        sysctl. Will throttle down to the currently maximum allowed frequency.
        See --strict-freq.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
--strict-freq
</term>
<listitem>
<simpara>
        Fail if the specified frequency can&#8217;t be used.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
-m
</term>
<term>
--mmap-pages=
</term>
<listitem>
<simpara>
        Number of mmap data pages (must be a power of two) or size
        specification with appended unit character - B/K/M/G. The
        size is rounded up to have nearest pages power of two value.
        Also, by adding a comma, the number of mmap pages for AUX
        area tracing can be specified.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
--group
</term>
<listitem>
<simpara>
        Put all events in a single event group.  This precedes the --event
        option and remains only for backward compatibility.  See --event.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
-g
</term>
<listitem>
<simpara>
        Enables call-graph (stack chain/backtrace) recording for both
        kernel space and user space.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
--call-graph
</term>
<listitem>
<simpara>
        Setup and enable call-graph (stack chain/backtrace) recording,
        implies -g.  Default is "fp" (for user space).
</simpara>
<literallayout class="monospaced">The unwinding method used for kernel space is dependent on the
unwinder used by the active kernel configuration, i.e
CONFIG_UNWINDER_FRAME_POINTER (fp) or CONFIG_UNWINDER_ORC (orc)</literallayout>
<literallayout class="monospaced">Any option specified here controls the method used for user space.</literallayout>
<literallayout class="monospaced">Valid options are "fp" (frame pointer), "dwarf" (DWARF's CFI -
Call Frame Information) or "lbr" (Hardware Last Branch Record
facility).</literallayout>
<literallayout class="monospaced">In some systems, where binaries are build with gcc
--fomit-frame-pointer, using the "fp" method will produce bogus
call graphs, using "dwarf", if available (perf tools linked to
the libunwind or libdw library) should be used instead.
Using the "lbr" method doesn't require any compiler options. It
will produce call graphs from the hardware LBR registers. The
main limitation is that it is only available on new Intel
platforms, such as Haswell. It can only get user call chain. It
doesn't work with branch stack sampling at the same time.</literallayout>
<literallayout class="monospaced">When "dwarf" recording is used, perf also records (user) stack dump
when sampled.  Default size of the stack dump is 8192 (bytes).
User can change the size by passing the size after comma like
"--call-graph dwarf,4096".</literallayout>
</listitem>
</varlistentry>
<varlistentry>
<term>
-q
</term>
<term>
--quiet
</term>
<listitem>
<simpara>
        Don&#8217;t print any message, useful for scripting.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
-v
</term>
<term>
--verbose
</term>
<listitem>
<simpara>
        Be more verbose (show counter open errors, etc).
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
-s
</term>
<term>
--stat
</term>
<listitem>
<simpara>
        Record per-thread event counts.  Use it with <emphasis>perf report -T</emphasis> to see
        the values.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
-d
</term>
<term>
--data
</term>
<listitem>
<simpara>
        Record the sample virtual addresses.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
--phys-data
</term>
<listitem>
<simpara>
        Record the sample physical addresses.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
--data-page-size
</term>
<listitem>
<simpara>
        Record the sampled data address data page size.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
--code-page-size
</term>
<listitem>
<simpara>
        Record the sampled code address (ip) page size
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
-T
</term>
<term>
--timestamp
</term>
<listitem>
<simpara>
        Record the sample timestamps. Use it with <emphasis>perf report -D</emphasis> to see the
        timestamps, for instance.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
-P
</term>
<term>
--period
</term>
<listitem>
<simpara>
        Record the sample period.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
--sample-cpu
</term>
<listitem>
<simpara>
        Record the sample cpu.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
-n
</term>
<term>
--no-samples
</term>
<listitem>
<simpara>
        Don&#8217;t sample.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
-R
</term>
<term>
--raw-samples
</term>
<listitem>
<simpara>
Collect raw sample records from all opened counters (default for tracepoint counters).
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
-C
</term>
<term>
--cpu
</term>
<listitem>
<simpara>
Collect samples only on the list of CPUs provided. Multiple CPUs can be provided as a
comma-separated list with no space: 0,1. Ranges of CPUs are specified with -: 0-2.
In per-thread mode with inheritance mode on (default), samples are captured only when
the thread executes on the designated CPUs. Default is to monitor all CPUs.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
-B
</term>
<term>
--no-buildid
</term>
<listitem>
<simpara>
Do not save the build ids of binaries in the perf.data files. This skips
post processing after recording, which sometimes makes the final step in
the recording process to take a long time, as it needs to process all
events looking for mmap records. The downside is that it can misresolve
symbols if the workload binaries used when recording get locally rebuilt
or upgraded, because the only key available in this case is the
pathname. You can also set the "record.build-id" config variable to
'skip to have this behaviour permanently.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
-N
</term>
<term>
--no-buildid-cache
</term>
<listitem>
<simpara>
Do not update the buildid cache. This saves some overhead in situations
where the information in the perf.data file (which includes buildids)
is sufficient.  You can also set the "record.build-id" config variable to
<emphasis>no-cache</emphasis> to have the same effect.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
-G name,&#8230;
</term>
<term>
--cgroup name,&#8230;
</term>
<listitem>
<simpara>
monitor only in the container (cgroup) called "name". This option is available only
in per-cpu mode. The cgroup filesystem must be mounted. All threads belonging to
container "name" are monitored when they run on the monitored CPUs. Multiple cgroups
can be provided. Each cgroup is applied to the corresponding event, i.e., first cgroup
to first event, second cgroup to second event and so on. It is possible to provide
an empty cgroup (monitor all the time) using, e.g., -G foo,,bar. Cgroups must have
corresponding events, i.e., they always refer to events defined earlier on the command
line. If the user wants to track multiple events for a specific cgroup, the user can
use <emphasis>-e e1 -e e2 -G foo,foo</emphasis> or just use <emphasis>-e e1 -e e2 -G foo</emphasis>.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>If wanting to monitor, say, <emphasis>cycles</emphasis> for a cgroup and also for system wide, this
command line can be used: <emphasis>perf stat -e cycles -G cgroup_name -a -e cycles</emphasis>.</simpara>
<variablelist>
<varlistentry>
<term>
-b
</term>
<term>
--branch-any
</term>
<listitem>
<simpara>
Enable taken branch stack sampling. Any type of taken branch may be sampled.
This is a shortcut for --branch-filter any. See --branch-filter for more infos.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
-j
</term>
<term>
--branch-filter
</term>
<listitem>
<simpara>
Enable taken branch stack sampling. Each sample captures a series of consecutive
taken branches. The number of branches captured with each sample depends on the
underlying hardware, the type of branches of interest, and the executed code.
It is possible to select the types of branches captured by enabling filters. The
following filters are defined:
</simpara>
<itemizedlist>
<listitem>
<simpara>
any:  any type of branches
</simpara>
</listitem>
<listitem>
<simpara>
any_call: any function call or system call
</simpara>
</listitem>
<listitem>
<simpara>
any_ret: any function return or system call return
</simpara>
</listitem>
<listitem>
<simpara>
ind_call: any indirect branch
</simpara>
</listitem>
<listitem>
<simpara>
call: direct calls, including far (to/from kernel) calls
</simpara>
</listitem>
<listitem>
<simpara>
u:  only when the branch target is at the user level
</simpara>
</listitem>
<listitem>
<simpara>
k: only when the branch target is in the kernel
</simpara>
</listitem>
<listitem>
<simpara>
hv: only when the target is at the hypervisor level
</simpara>
</listitem>
<listitem>
<simpara>
in_tx: only when the target is in a hardware transaction
</simpara>
</listitem>
<listitem>
<simpara>
no_tx: only when the target is not in a hardware transaction
</simpara>
</listitem>
<listitem>
<simpara>
abort_tx: only when the target is a hardware transaction abort
</simpara>
</listitem>
<listitem>
<simpara>
cond: conditional branches
</simpara>
</listitem>
<listitem>
<simpara>
save_type: save branch type during sampling in case binary is not available later
</simpara>
</listitem>
</itemizedlist>
<simpara>The option requires at least one branch type among any, any_call, any_ret, ind_call, cond.
The privilege levels may be omitted, in which case, the privilege levels of the associated
event are applied to the branch filter. Both kernel (k) and hypervisor (hv) privilege
levels are subject to permissions.  When sampling on multiple events, branch stack sampling
is enabled for all the sampling events. The sampled branch type is the same for all events.
The various filters must be specified as a comma separated list: --branch-filter any_ret,u,k
Note that this feature may not be available on all processors.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
--weight
</term>
<listitem>
<simpara>
Enable weightened sampling. An additional weight is recorded per sample and can be
displayed with the weight and local_weight sort keys.  This currently works for TSX
abort events and some memory events in precise mode on modern Intel CPUs.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
--namespaces
</term>
<listitem>
<simpara>
Record events of type PERF_RECORD_NAMESPACES.  This enables <emphasis>cgroup_id</emphasis> sort key.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
--all-cgroups
</term>
<listitem>
<simpara>
Record events of type PERF_RECORD_CGROUP.  This enables <emphasis>cgroup</emphasis> sort key.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
--transaction
</term>
<listitem>
<simpara>
Record transaction flags for transaction related events.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
--per-thread
</term>
<listitem>
<simpara>
Use per-thread mmaps.  By default per-cpu mmaps are created.  This option
overrides that and uses per-thread mmaps.  A side-effect of that is that
inheritance is automatically disabled.  --per-thread is ignored with a warning
if combined with -a or -C options.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
-D
</term>
<term>
--delay=
</term>
<listitem>
<simpara>
After starting the program, wait msecs before measuring (-1: start with events
disabled). This is useful to filter out the startup phase of the program, which
is often very different.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
-I
</term>
<term>
--intr-regs
</term>
<listitem>
<simpara>
Capture machine state (registers) at interrupt, i.e., on counter overflows for
each sample. List of captured registers depends on the architecture. This option
is off by default. It is possible to select the registers to sample using their
symbolic names, e.g. on x86, ax, si. To list the available registers use
--intr-regs=\?. To name registers, pass a comma separated list such as
--intr-regs=ax,bx. The list of register is architecture dependent.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
--user-regs
</term>
<listitem>
<simpara>
Similar to -I, but capture user registers at sample time. To list the available
user registers use --user-regs=\?.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
--running-time
</term>
<listitem>
<simpara>
Record running and enabled time for read events (:S)
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
-k
</term>
<term>
--clockid
</term>
<listitem>
<simpara>
Sets the clock id to use for the various time fields in the perf_event_type
records. See clock_gettime(). In particular CLOCK_MONOTONIC and
CLOCK_MONOTONIC_RAW are supported, some events might also allow
CLOCK_BOOTTIME, CLOCK_REALTIME and CLOCK_TAI.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
-S
</term>
<term>
--snapshot
</term>
<listitem>
<simpara>
Select AUX area tracing Snapshot Mode. This option is valid only with an
AUX area tracing event. Optionally, certain snapshot capturing parameters
can be specified in a string that follows this option:
  <emphasis>e</emphasis>: take one last snapshot on exit; guarantees that there is at least one
       snapshot in the output file;
  &lt;size&gt;: if the PMU supports this, specify the desired snapshot size.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>In Snapshot Mode trace data is captured only when signal SIGUSR2 is received
and on exit if the above <emphasis>e</emphasis> option is given.</simpara>
<variablelist>
<varlistentry>
<term>
--aux-sample[=OPTIONS]
</term>
<listitem>
<simpara>
Select AUX area sampling. At least one of the events selected by the -e option
must be an AUX area event. Samples on other events will be created containing
data from the AUX area. Optionally sample size may be specified, otherwise it
defaults to 4KiB.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
--proc-map-timeout
</term>
<listitem>
<simpara>
When processing pre-existing threads /proc/XXX/mmap, it may take a long time,
because the file may be huge. A time out is needed in such cases.
This option sets the time out limit. The default value is 500 ms.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
--switch-events
</term>
<listitem>
<simpara>
Record context switch events i.e. events of type PERF_RECORD_SWITCH or
PERF_RECORD_SWITCH_CPU_WIDE. In some cases (e.g. Intel PT, CoreSight or Arm SPE)
switch events will be enabled automatically, which can be suppressed by
by the option --no-switch-events.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
--clang-path=PATH
</term>
<listitem>
<simpara>
Path to clang binary to use for compiling BPF scriptlets.
(enabled when BPF support is on)
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
--clang-opt=OPTIONS
</term>
<listitem>
<simpara>
Options passed to clang when compiling BPF scriptlets.
(enabled when BPF support is on)
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
--vmlinux=PATH
</term>
<listitem>
<simpara>
Specify vmlinux path which has debuginfo.
(enabled when BPF prologue is on)
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
--buildid-all
</term>
<listitem>
<simpara>
Record build-id of all DSOs regardless whether it&#8217;s actually hit or not.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
--buildid-mmap
</term>
<listitem>
<simpara>
Record build ids in mmap2 events, disables build id cache (implies --no-buildid).
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
--aio[=n]
</term>
<listitem>
<simpara>
Use &lt;n&gt; control blocks in asynchronous (Posix AIO) trace writing mode (default: 1, max: 4).
Asynchronous mode is supported only when linking Perf tool with libc library
providing implementation for Posix AIO API.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
--affinity=mode
</term>
<listitem>
<simpara>
Set affinity mask of trace reading thread according to the policy defined by <emphasis>mode</emphasis> value:
  node - thread affinity mask is set to NUMA node cpu mask of the processed mmap buffer
  cpu  - thread affinity mask is set to cpu of the processed mmap buffer
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
--mmap-flush=number
</term>
<listitem>
<simpara>
Specify minimal number of bytes that is extracted from mmap data pages and
processed for output. One can specify the number using B/K/M/G suffixes.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>The maximal allowed value is a quarter of the size of mmaped data pages.</simpara>
<simpara>The default option value is 1 byte which means that every time that the output
writing thread finds some new data in the mmaped buffer the data is extracted,
possibly compressed (-z) and written to the output, perf.data or pipe.</simpara>
<simpara>Larger data chunks are compressed more effectively in comparison to smaller
chunks so extraction of larger chunks from the mmap data pages is preferable
from the perspective of output size reduction.</simpara>
<simpara>Also at some cases executing less output write syscalls with bigger data size
can take less time than executing more output write syscalls with smaller data
size thus lowering runtime profiling overhead.</simpara>
<variablelist>
<varlistentry>
<term>
-z
</term>
<term>
--compression-level[=n]
</term>
<listitem>
<simpara>
Produce compressed trace using specified level n (default: 1 - fastest compression,
22 - smallest trace)
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
--all-kernel
</term>
<listitem>
<simpara>
Configure all used events to run in kernel space.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
--all-user
</term>
<listitem>
<simpara>
Configure all used events to run in user space.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
--kernel-callchains
</term>
<listitem>
<simpara>
Collect callchains only from kernel space. I.e. this option sets
perf_event_attr.exclude_callchain_user to 1.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
--user-callchains
</term>
<listitem>
<simpara>
Collect callchains only from user space. I.e. this option sets
perf_event_attr.exclude_callchain_kernel to 1.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Don&#8217;t use both --kernel-callchains and --user-callchains at the same time or no
callchains will be collected.</simpara>
<simpara>--timestamp-filename
Append timestamp to output file name.</simpara>
<variablelist>
<varlistentry>
<term>
--timestamp-boundary
</term>
<listitem>
<simpara>
Record timestamp boundary (time of first/last samples).
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
--switch-output[=mode]
</term>
<listitem>
<simpara>
Generate multiple perf.data files, timestamp prefixed, switching to a new one
based on <emphasis>mode</emphasis> value:
  "signal" - when receiving a SIGUSR2 (default value) or
  &lt;size&gt;   - when reaching the size threshold, size is expected to
             be a number with appended unit character - B/K/M/G
  &lt;time&gt;   - when reaching the time threshold, size is expected to
             be a number with appended unit character - s/m/h/d
</simpara>
<literallayout class="monospaced">Note: the precision of  the size  threshold  hugely depends
on your configuration  - the number and size of  your  ring
buffers (-m). It is generally more precise for higher sizes
(like &gt;5M), for lower values expect different sizes.</literallayout>
</listitem>
</varlistentry>
</variablelist>
<simpara>A possible use case is to, given an external event, slice the perf.data file
that gets then processed, possibly via a perf script, to decide if that
particular perf.data snapshot should be kept or not.</simpara>
<simpara>Implies --timestamp-filename, --no-buildid and --no-buildid-cache.
The reason for the latter two is to reduce the data file switching
overhead. You can still switch them on with:</simpara>
<literallayout class="monospaced">--switch-output --no-no-buildid  --no-no-buildid-cache</literallayout>
<variablelist>
<varlistentry>
<term>
--switch-output-event
</term>
<listitem>
<simpara>
Events that will cause the switch of the perf.data file, auto-selecting
--switch-output=signal, the results are similar as internally the side band
thread will also send a SIGUSR2 to the main one.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Uses the same syntax as --event, it will just not be recorded, serving only to
switch the perf.data file as soon as the --switch-output event is processed by
a separate sideband thread.</simpara>
<simpara>This sideband thread is also used to other purposes, like processing the
PERF_RECORD_BPF_EVENT records as they happen, asking the kernel for extra BPF
information, etc.</simpara>
<variablelist>
<varlistentry>
<term>
--switch-max-files=N
</term>
<listitem>
<simpara>
When rotating perf.data with --switch-output, only keep N files.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
--dry-run
</term>
<listitem>
<simpara>
Parse options then exit. --dry-run can be used to detect errors in cmdline
options.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara><emphasis>perf record --dry-run -e</emphasis> can act as a BPF script compiler if llvm.dump-obj
in config file is set to true.</simpara>
<variablelist>
<varlistentry>
<term>
--synth=TYPE
</term>
<listitem>
<simpara>
Collect and synthesize given type of events (comma separated).  Note that
this option controls the synthesis from the /proc filesystem which represent
task status for pre-existing threads.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Kernel (and some other) events are recorded regardless of the
choice in this option.  For example, --synth=no would have MMAP events for
kernel and modules.</simpara>
<simpara>Available types are:
  <emphasis>task</emphasis>    - synthesize FORK and COMM events for each task
  <emphasis>mmap</emphasis>    - synthesize MMAP events for each process (implies <emphasis>task</emphasis>)
  <emphasis>cgroup</emphasis>  - synthesize CGROUP events for each cgroup
  <emphasis>all</emphasis>     - synthesize all events (default)
  <emphasis>no</emphasis>      - do not synthesize any of the above events</simpara>
<variablelist>
<varlistentry>
<term>
--tail-synthesize
</term>
<listitem>
<simpara>
Instead of collecting non-sample events (for example, fork, comm, mmap) at
the beginning of record, collect them during finalizing an output file.
The collected non-sample events reflects the status of the system when
record is finished.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
--overwrite
</term>
<listitem>
<simpara>
Makes all events use an overwritable ring buffer. An overwritable ring
buffer works like a flight recorder: when it gets full, the kernel will
overwrite the oldest records, that thus will never make it to the
perf.data file.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>When <emphasis>--overwrite</emphasis> and <emphasis>--switch-output</emphasis> are used perf records and drops
events until it receives a signal, meaning that something unusual was
detected that warrants taking a snapshot of the most current events,
those fitting in the ring buffer at that moment.</simpara>
<simpara><emphasis>overwrite</emphasis> attribute can also be set or canceled for an event using
config terms. For example: <emphasis>cycles/overwrite/</emphasis> and <emphasis>instructions/no-overwrite/</emphasis>.</simpara>
<simpara>Implies --tail-synthesize.</simpara>
<variablelist>
<varlistentry>
<term>
--kcore
</term>
<listitem>
<simpara>
Make a copy of /proc/kcore and place it into a directory with the perf data file.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
--max-size=&lt;size&gt;
</term>
<listitem>
<simpara>
Limit the sample data max size, &lt;size&gt; is expected to be a number with
appended unit character - B/K/M/G
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
--num-thread-synthesize
</term>
<listitem>
<simpara>
        The number of threads to run when synthesizing events for existing processes.
        By default, the number of threads equals 1.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
--control=fifo:ctl-fifo[,ack-fifo]
</term>
<term>
--control=fd:ctl-fd[,ack-fd]
</term>
<listitem>
<simpara>
ctl-fifo / ack-fifo are opened and used as ctl-fd / ack-fd as follows.
Listen on ctl-fd descriptor for command to control measurement.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Available commands:
  <emphasis>enable</emphasis>           : enable events
  <emphasis>disable</emphasis>          : disable events
  <emphasis>enable name</emphasis>      : enable event <emphasis>name</emphasis>
  <emphasis>disable name</emphasis>     : disable event <emphasis>name</emphasis>
  <emphasis>snapshot</emphasis>         : AUX area tracing snapshot).
  <emphasis>stop</emphasis>             : stop perf record
  <emphasis>ping</emphasis>             : ping</simpara>
<literallayout class="monospaced">'evlist [-v|-g|-F] : display all events
                     -F  Show just the sample frequency used for each event.
                     -v  Show all fields.
                     -g  Show event group information.</literallayout>
<simpara>Measurements can be started with events disabled using --delay=-1 option. Optionally
send control command completion (<emphasis>ack\n</emphasis>) to ack-fd descriptor to synchronize with the
controlling process.  Example of bash shell script to enable and disable events during
measurements:</simpara>
<literallayout class="monospaced">#!/bin/bash</literallayout>
<literallayout class="monospaced">ctl_dir=/tmp/</literallayout>
<literallayout class="monospaced">ctl_fifo=${ctl_dir}perf_ctl.fifo
test -p ${ctl_fifo} &amp;&amp; unlink ${ctl_fifo}
mkfifo ${ctl_fifo}
exec {ctl_fd}&lt;&gt;${ctl_fifo}</literallayout>
<literallayout class="monospaced">ctl_ack_fifo=${ctl_dir}perf_ctl_ack.fifo
test -p ${ctl_ack_fifo} &amp;&amp; unlink ${ctl_ack_fifo}
mkfifo ${ctl_ack_fifo}
exec {ctl_fd_ack}&lt;&gt;${ctl_ack_fifo}</literallayout>
<literallayout class="monospaced">perf record -D -1 -e cpu-cycles -a               \
            --control fd:${ctl_fd},${ctl_fd_ack} \
            -- sleep 30 &amp;
perf_pid=$!</literallayout>
<literallayout class="monospaced">sleep 5  &amp;&amp; echo 'enable' &gt;&amp;${ctl_fd} &amp;&amp; read -u ${ctl_fd_ack} e1 &amp;&amp; echo "enabled(${e1})"
sleep 10 &amp;&amp; echo 'disable' &gt;&amp;${ctl_fd} &amp;&amp; read -u ${ctl_fd_ack} d1 &amp;&amp; echo "disabled(${d1})"</literallayout>
<literallayout class="monospaced">exec {ctl_fd_ack}&gt;&amp;-
unlink ${ctl_ack_fifo}</literallayout>
<literallayout class="monospaced">exec {ctl_fd}&gt;&amp;-
unlink ${ctl_fifo}</literallayout>
<literallayout class="monospaced">wait -n ${perf_pid}
exit $?</literallayout>
</refsect1>
<refsect1 id="_intel_hybrid_support">
<title>Intel hybrid support</title>
<simpara>Support for Intel hybrid events within perf tools.</simpara>
<simpara>For some Intel platforms, such as AlderLake, which is hybrid platform and
it consists of atom cpu and core cpu. Each cpu has dedicated event list.
Part of events are available on core cpu, part of events are available
on atom cpu and even part of events are available on both.</simpara>
<simpara>Kernel exports two new cpu pmus via sysfs:
/sys/devices/cpu_core
/sys/devices/cpu_atom</simpara>
<simpara>The <emphasis>cpus</emphasis> files are created under the directories. For example,</simpara>
<simpara>cat /sys/devices/cpu_core/cpus
0-15</simpara>
<simpara>cat /sys/devices/cpu_atom/cpus
16-23</simpara>
<simpara>It indicates cpu0-cpu15 are core cpus and cpu16-cpu23 are atom cpus.</simpara>
<simpara>Quickstart</simpara>
</refsect1>
<refsect1 id="_list_hybrid_event">
<title>List hybrid event</title>
<simpara>As before, use perf-list to list the symbolic event.</simpara>
<simpara>perf list</simpara>
<simpara>inst_retired.any
        [Fixed Counter: Counts the number of instructions retired. Unit: cpu_atom]
inst_retired.any
        [Number of instructions retired. Fixed Counter - architectural event. Unit: cpu_core]</simpara>
<simpara>The <emphasis>Unit: xxx</emphasis> is added to brief description to indicate which pmu
the event is belong to. Same event name but with different pmu can
be supported.</simpara>
</refsect1>
<refsect1 id="_enable_hybrid_event_with_a_specific_pmu">
<title>Enable hybrid event with a specific pmu</title>
<simpara>To enable a core only event or atom only event, following syntax is supported:</simpara>
<literallayout class="monospaced">        cpu_core/&lt;event name&gt;/
or
        cpu_atom/&lt;event name&gt;/</literallayout>
<simpara>For example, count the <emphasis>cycles</emphasis> event on core cpus.</simpara>
<literallayout class="monospaced">perf stat -e cpu_core/cycles/</literallayout>
</refsect1>
<refsect1 id="_create_two_events_for_one_hardware_event_automatically">
<title>Create two events for one hardware event automatically</title>
<simpara>When creating one event and the event is available on both atom and core,
two events are created automatically. One is for atom, the other is for
core. Most of hardware events and cache events are available on both
cpu_core and cpu_atom.</simpara>
<simpara>For hardware events, they have pre-defined configs (e.g. 0 for cycles).
But on hybrid platform, kernel needs to know where the event comes from
(from atom or from core). The original perf event type PERF_TYPE_HARDWARE
can&#8217;t carry pmu information. So now this type is extended to be PMU aware
type. The PMU type ID is stored at attr.config[63:32].</simpara>
<simpara>PMU type ID is retrieved from sysfs.
/sys/devices/cpu_atom/type
/sys/devices/cpu_core/type</simpara>
<simpara>The new attr.config layout for PERF_TYPE_HARDWARE:</simpara>
<simpara>PERF_TYPE_HARDWARE:                 0xEEEEEEEE000000AA
                                    AA: hardware event ID
                                    EEEEEEEE: PMU type ID</simpara>
<simpara>Cache event is similar. The type PERF_TYPE_HW_CACHE is extended to be
PMU aware type. The PMU type ID is stored at attr.config[63:32].</simpara>
<simpara>The new attr.config layout for PERF_TYPE_HW_CACHE:</simpara>
<simpara>PERF_TYPE_HW_CACHE:                 0xEEEEEEEE00DDCCBB
                                    BB: hardware cache ID
                                    CC: hardware cache op ID
                                    DD: hardware cache op result ID
                                    EEEEEEEE: PMU type ID</simpara>
<simpara>When enabling a hardware event without specified pmu, such as,
perf stat -e cycles -a (use system-wide in this example), two events
are created automatically.</simpara>
<literallayout class="monospaced">------------------------------------------------------------
perf_event_attr:
  size                             120
  config                           0x400000000
  sample_type                      IDENTIFIER
  read_format                      TOTAL_TIME_ENABLED|TOTAL_TIME_RUNNING
  disabled                         1
  inherit                          1
  exclude_guest                    1
------------------------------------------------------------</literallayout>
<simpara>and</simpara>
<literallayout class="monospaced">------------------------------------------------------------
perf_event_attr:
  size                             120
  config                           0x800000000
  sample_type                      IDENTIFIER
  read_format                      TOTAL_TIME_ENABLED|TOTAL_TIME_RUNNING
  disabled                         1
  inherit                          1
  exclude_guest                    1
------------------------------------------------------------</literallayout>
<simpara>type 0 is PERF_TYPE_HARDWARE.
0x4 in 0x400000000 indicates it&#8217;s cpu_core pmu.
0x8 in 0x800000000 indicates it&#8217;s cpu_atom pmu (atom pmu type id is random).</simpara>
<simpara>The kernel creates <emphasis>cycles</emphasis> (0x400000000) on cpu0-cpu15 (core cpus),
and create <emphasis>cycles</emphasis> (0x800000000) on cpu16-cpu23 (atom cpus).</simpara>
<simpara>For perf-stat result, it displays two events:</simpara>
<literallayout class="monospaced">Performance counter stats for 'system wide':</literallayout>
<literallayout class="monospaced">6,744,979      cpu_core/cycles/
1,965,552      cpu_atom/cycles/</literallayout>
<simpara>The first <emphasis>cycles</emphasis> is core event, the second <emphasis>cycles</emphasis> is atom event.</simpara>
</refsect1>
<refsect1 id="_thread_mode_example">
<title>Thread mode example:</title>
<simpara>perf-stat reports the scaled counts for hybrid event and with a percentage
displayed. The percentage is the event&#8217;s running time/enabling time.</simpara>
<simpara>One example, <emphasis>triad_loop</emphasis> runs on cpu16 (atom core), while we can see the
scaled value for core cycles is 160,444,092 and the percentage is 0.47%.</simpara>
<simpara>perf stat -e cycles -- taskset -c 16 ./triad_loop</simpara>
<simpara>As previous, two events are created.</simpara>
<literallayout>
&#10;.ft C&#10;perf_event_attr:
  size                             120
  config                           0x400000000
  sample_type                      IDENTIFIER
  read_format                      TOTAL_TIME_ENABLED|TOTAL_TIME_RUNNING
  disabled                         1
  inherit                          1
  enable_on_exec                   1
  exclude_guest                    1&#10;.ft&#10;
</literallayout>
<simpara>and</simpara>
<literallayout>
&#10;.ft C&#10;perf_event_attr:
  size                             120
  config                           0x800000000
  sample_type                      IDENTIFIER
  read_format                      TOTAL_TIME_ENABLED|TOTAL_TIME_RUNNING
  disabled                         1
  inherit                          1
  enable_on_exec                   1
  exclude_guest                    1&#10;.ft&#10;
</literallayout>
<literallayout class="monospaced">Performance counter stats for 'taskset -c 16 ./triad_loop':</literallayout>
<literallayout class="monospaced">233,066,666      cpu_core/cycles/                                              (0.43%)
604,097,080      cpu_atom/cycles/                                              (99.57%)</literallayout>
</refsect1>
<refsect1 id="_perf_record">
<title>perf-record:</title>
<simpara>If there is no <emphasis>-e</emphasis> specified in perf record, on hybrid platform,
it creates two default <emphasis>cycles</emphasis> and adds them to event list. One
is for core, the other is for atom.</simpara>
</refsect1>
<refsect1 id="_perf_stat">
<title>perf-stat:</title>
<simpara>If there is no <emphasis>-e</emphasis> specified in perf stat, on hybrid platform,
besides of software events, following events are created and
added to event list in order.</simpara>
<simpara>cpu_core/cycles/,
cpu_atom/cycles/,
cpu_core/instructions/,
cpu_atom/instructions/,
cpu_core/branches/,
cpu_atom/branches/,
cpu_core/branch-misses/,
cpu_atom/branch-misses/</simpara>
<simpara>Of course, both perf-stat and perf-record support to enable
hybrid event with a specific pmu.</simpara>
<simpara>e.g.
perf stat -e cpu_core/cycles/
perf stat -e cpu_atom/cycles/
perf stat -e cpu_core/r1a/
perf stat -e cpu_atom/L1-icache-loads/
perf stat -e cpu_core/cycles/,cpu_atom/instructions/
perf stat -e <emphasis>{cpu_core/cycles/,cpu_core/instructions/}</emphasis></simpara>
<simpara>But <emphasis>{cpu_core/cycles/,cpu_atom/instructions/}</emphasis> will return
warning and disable grouping, because the pmus in group are
not matched (cpu_core vs. cpu_atom).</simpara>
<variablelist>
<varlistentry>
<term>
--debuginfod[=URLs]
</term>
<listitem>
<simpara>
        Specify debuginfod URL to be used when cacheing perf.data binaries,
        it follows the same syntax as the DEBUGINFOD_URLS variable, like:
</simpara>
<literallayout class="monospaced">http://192.168.122.174:8002</literallayout>
<literallayout class="monospaced">If the URLs is not specified, the value of DEBUGINFOD_URLS
system environment variable is used.</literallayout>
</listitem>
</varlistentry>
</variablelist>
</refsect1>
<refsect1 id="_see_also">
<title>SEE ALSO</title>
<simpara><citerefentry>
<refentrytitle>perf-stat</refentrytitle><manvolnum>1</manvolnum>
</citerefentry>, <citerefentry>
<refentrytitle>perf-list</refentrytitle><manvolnum>1</manvolnum>
</citerefentry>, <citerefentry>
<refentrytitle>perf-intel-pt</refentrytitle><manvolnum>1</manvolnum>
</citerefentry></simpara>
</refsect1>
</refentry>
